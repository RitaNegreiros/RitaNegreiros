# -*- coding: utf-8 -*-
"""Codigos Todos os Experimentos - SSC_SIR Adaptado_Projeçao_DadosColetados.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15Sn3y9LihSESCP_Lxic65VIvdVnJpPR6

##### IMPORTANTE **** Para a defesa os codigos novos a serem executados sao os 10 e 11
::: os anteriores foram criados nos primeiros experimentos
"""

# Readme
# IMPORTANTE **** Para a defesa os codigos novos a serem executados sao os 10 11 12::: os anteriores foram criados nos primeiros experimentos
# os códigos estao organizados na seguinte ordem:
# 01 Experimento 01 Yanomami Reaçoes Facebook ***Antes da Qualificacao # MESMO CODIGO 01 02
# 02 Experimento 01 Yanomami Sensemaking Facebook ***Antes da Qualificacao # MESMO CODIGO 01 02
# 03 Experimento 02 Meteoro Reaçoes Facebook ***Antes da Qualificacao # MESMO CODIGO 03 04
# 04 Experimento 02 Meteoro Sensemaking Facebook ***Antes da Qualificacao # MESMO CODIGO 03 04
# FALTA CRIAR PERDIDO UTILIZAR CODIGO 08 - 05 Experimento 02 Meteoro Facebook Projeção Modelo SIR ***PENDENTE
# 06 Experimento 02 Meteoro Reaçoes X (Twitter) Coleta manual ***Antes da Qualificacao # MESMO CODIGO Figura 06 E 07
# 07 Experimento 02 Meteoro Sensemaking X (Twitter) Coleta manual ***Antes da Qualificacao # MESMO CODIGO Figura 06 E 07
# 08 Experimento 02 Meteoro X (Twitter) Coleta manual Projeção Modelo SIR ***Antes da Qualificacao
# 09 Experimento 03 API Youtube Dia 1 Projeção Modelo SI/SIR *CRIADO ANTES DA DEFINICAO DO SIR ADAPTADO
# 10 Experimento 04 API Youtube Dia 1 Projeção Modelo SIR Adaptado SSC
# 11 Experimento 04 Modelo SIR Adaptado SSC Retorna as taxas Beta;Gamma;Delta ***Planilha qualquer midia -- por dia
# 12 Experimento 04 Modelo SIR Projecao
# 13 Experimento 04 Modelo SIR Retorna as taxas Beta;Gamma ***Planilha qualquer midia
# 14 Experimento 04 Modelo SIR Retorna as taxas Beta;Gamma ***JSON Youtube
# Tentantivas anteriores
#     Modelo SIR Fixo
#     Tentativa modelo SIR Adaptado Fixo
#     Exemplo OLD SIR fixo
#     Exemplo OLD SIRD fixo

# Versoes
# Versão 2.0 30/07/2025 11 Taxas por dia
# Versão 1.0 23/07/2025 Enviado professores

# ARQUIVOS UPLOAD COLAB - Arquivos disponivel no github https://github.com/RitaNegreiros/RitaNegreiros_Mestrado_Colab.git

# ANALISE TWITTER.csv
# HN21Fs3_OUM_estatistica.json
# analise_sir_data.json
# analise_ssc_data.json
# data.json
# estatistica_X_SSC.xlsx
# estatistica_youtube_SSC.xlsx
# estatistica_facebook_SSC.xlsx
# estatistica_facebook_Yanomami_SSC.xlsx
# post.csv

# 01 Experimento 01 Yanomami Reaçoes Facebook
# 02 Experimento 01 Yanomami Sensemaking Facebook

from numpy import zeros, linspace
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.pyplot as plt
import csv
import json

def csv_to_json(csvFilePath, jsonFilePath):
    jsonArray = []

    #read csv file
    with open(csvFilePath, encoding='utf-8') as csvf:
        #load csv file data using csv library's dictionary readerreações- 24 Set
        csvReader = csv.DictReader(csvf)

        #convert each csv row into python dict
        for row in csvReader:
            #add this python dict to json array
            jsonArray.insert(0, row)

    #convert python jsonArray to JSON String and write to file
    with open(jsonFilePath, 'w', encoding='utf-8') as jsonf:
        jsonString = json.dumps(jsonArray, indent=4)
        jsonf.write(jsonString)

    def getTimeStep(data):
        step = data["Timestep"]
        return int(step)

    def getTimeDate(data):
        date = data["Score Date (GMT)"]
        return date

    def getLikes(data):
        likes = data["Likes"]
        return int(likes)

    def getComments(data):
        comment = data["Comments"]
        return int(comment)

    def getLoves(data):
        loves = data["Loves"]
        return int(loves)

    def getShares(data):
        shares = data["Shares"]
        return int(shares)

    def getPostViews(data):
        views = data["Total Views"]
        return int(views)

    def getSads(data):
        sads = data["Sads"]
        return int(sads)

    def getAngrys(data):
        anglys = data["Angrys"]
        return int(anglys)

    def getHaHas(data):
        hahas = data["Hahas"]
        return int(hahas)

    def getCares(data):
        cares = data["Cares"]
        return int(cares)

    def getAllReactions(data):
        likes = data["Likes"]
        loves = data["Loves"]
        cares = data["Cares"]
        hahas = data["Hahas"]
        sads = data["Sads"]
        anglys = data["Angrys"]
        return int(int(likes) +  int(loves) + int(cares) + int(hahas) + int(sads) + int(anglys))

    def getAsymptContaminated(data):
        views = data["Post Views"]
        shares = data["Shares"]
        return int(int(views) - int(shares))

    newTimesDates = list(map(getTimeDate, jsonArray))
    newTimesteps = list(map(getTimeStep, jsonArray))
    newLikes = list(map(getLikes, jsonArray))
    newComments = list(map(getComments, jsonArray))
    newLoves = list(map(getLoves, jsonArray))
    newShares = list(map(getShares, jsonArray))
    newPostViews = list(map(getPostViews, jsonArray))
    newSads = list(map(getSads, jsonArray))
    newAngrys = list(map(getAngrys, jsonArray))
    newHahas = list(map(getHaHas,jsonArray))
    newCares = list(map(getCares,jsonArray))
    newAllReactions = list(map(getAllReactions,jsonArray))
    newAsymptContaminated = list(map(getAsymptContaminated,jsonArray))

    # Build chart
    fig1, ax = plt.subplots(figsize=(10 , 5), constrained_layout=True)
    plt.setp(ax.get_xticklabels(), rotation=30, ha="right")
    plt.rcParams.update({'font.size': 12})
    plt.rc('axes', titlesize=24)

    plt.plot(newTimesteps,newComments,color='maroon',label='Comentários')
    plt.plot(newTimesteps,newShares,color='limeGreen',label='Compartilhamentos')
    plt.plot(newTimesteps,newPostViews,color='blue',label='Visualizações')
    plt.plot(newTimesteps,newAllReactions,color='magenta',label='Reações')

    print("\nGRÁFICO DE REAÇÕES 2: ")
    print("\nsoma de reações: ",newAllReactions)
    print("\ncomentarios: ",newComments)
    print("\ncompartilhamentos: ",newShares)
    print("\nvisualizações: ",newPostViews)


    plt.xlabel('Timestep')
    plt.ylabel('Quantidade')
    plt.title(str(chartTitleReaction))
    plt.legend()

    fig1.tight_layout()

    plt.savefig('fig01_Yanomami_Reacoes.png')
    fig1.show()

    fig2, ax = plt.subplots(figsize=(10 , 5), constrained_layout=True)
    plt.setp(ax.get_xticklabels(), rotation=30, ha="right")
    plt.rcParams.update({'font.size': 12})
    plt.rc('axes', titlesize=24)

    plt.plot(newTimesteps,newPostViews,color='purple',label='Infectados (visualizações)')
    plt.plot(newTimesteps,newAllReactions,color='lightBlue',label='Recuperados (soma de reações)')
    plt.plot(newTimesteps,newAsymptContaminated,color='darkOliveGreen',label='Contaminados assintomáticos (visualizaram mas não compartilharam)')
    plt.plot(newTimesteps,newShares,color='limeGreen',label='Contaminados sintomáticos (compartilharam)')


    print("\nrecuperados (soma de reações): ",newAllReactions)
    print("\ninfectados (visualizações): ",newPostViews)
    print("\ncontaminados assintomáticos (visualizaram mas não compartilharam): ",newAsymptContaminated)
    print("\ncontaminados sintomáticos (compartilharam): ",newShares)

    plt.xlabel('Timestep')
    plt.ylabel('Quantidade')
    plt.title(str(chartTitleSenseMake))
    plt.legend()

    tex = "Seguidores:\n " + str(followings)
    ax.text(5, 300, tex, fontsize=16, va='center', color="blue")

    fig2.tight_layout()

    plt.savefig('fig02_Yanomami_Sentimentos.png')
    fig2.show()

print("\nGráfico construido com sucesso!\n\n")

# chartTitleReaction = input("Informe o título do gráfico de reações: ")
# chartTitleSenseMake = input("Informe o título do gráfico de sentimentos: ")
# followings = int(input("Informe o número de seguidores: "))
chartTitleReaction = "Quantidade de reações mensagem Yanomami"
chartTitleSenseMake = "Sensemaking mensagem Yanomami"
followings = "2740909"

csvFilePath = r'history_post_6367827886583037.csv'
jsonFilePath = r'yanomami_data.json'
csv_to_json(csvFilePath, jsonFilePath)

# 03 Experimento 02 Meteoro Sensemaking Facebook
# 04 Experimento 02 Meteoro Facebook Projeção Modelo SIR
# Figura 04 E 05 MESMO CODIGO 03 04

from numpy import zeros, linspace
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.pyplot as plt
import csv
import json

def csv_to_json(csvFilePath, jsonFilePath):
    jsonArray = []

    #read csv file
    with open(csvFilePath, encoding='utf-8') as csvf:
        #load csv file data using csv library's dictionary readerreações- 24 Set
        csvReader = csv.DictReader(csvf)

        #convert each csv row into python dict
        for row in csvReader:
            #add this python dict to json array
            jsonArray.insert(0, row)

    #convert python jsonArray to JSON String and write to file
    with open(jsonFilePath, 'w', encoding='utf-8') as jsonf:
        jsonString = json.dumps(jsonArray, indent=4)
        jsonf.write(jsonString)

    def getTimeStep(data):
        step = data["Timestep"]
        return int(step)

    def getTimeDate(data):
        date = data["Score Date (GMT)"]
        return date

    def getLikes(data):
        likes = data["Likes"]
        return int(likes)

    def getComments(data):
        comment = data["Comments"]
        return int(comment)

    def getLoves(data):
        loves = data["Loves"]
        return int(loves)

    def getShares(data):
        shares = data["Shares"]
        return int(shares)

    def getPostViews(data):
        views = data["Total Views"]
        return int(views)

    def getSads(data):
        sads = data["Sads"]
        return int(sads)

    def getAngrys(data):
        anglys = data["Angrys"]
        return int(anglys)

    def getHaHas(data):
        hahas = data["Hahas"]
        return int(hahas)

    def getCares(data):
        cares = data["Cares"]
        return int(cares)

    def getAllReactions(data):
        likes = data["Likes"]
        loves = data["Loves"]
        cares = data["Cares"]
        hahas = data["Hahas"]
        sads = data["Sads"]
        anglys = data["Angrys"]
        return int(int(likes) +  int(loves) + int(cares) + int(hahas) + int(sads) + int(anglys))

    def getAsymptContaminated(data):
        likes = data["Likes"]
        comments = data["Comments"]
        return int(int(likes) - int(comments))

    newTimesDates = list(map(getTimeDate, jsonArray))
    newTimesteps = list(map(getTimeStep, jsonArray))
    newLikes = list(map(getLikes, jsonArray))
    newComments = list(map(getComments, jsonArray))
    newLoves = list(map(getLoves, jsonArray))
    newShares = list(map(getShares, jsonArray))
    newPostViews = list(map(getPostViews, jsonArray))
    newSads = list(map(getSads, jsonArray))
    newAngrys = list(map(getAngrys, jsonArray))
    newHahas = list(map(getHaHas,jsonArray))
    newCares = list(map(getCares,jsonArray))
    newAllReactions = list(map(getAllReactions,jsonArray))
    newAsymptContaminated = list(map(getAsymptContaminated,jsonArray))

    # Build chart
    fig1, ax = plt.subplots(figsize=(10 , 5), constrained_layout=True)
    plt.setp(ax.get_xticklabels(), rotation=30, ha="right")
    plt.rcParams.update({'font.size': 12})
    plt.rc('axes', titlesize=24)

    plt.plot(newTimesteps,newLikes,color='green',label='Curtidas')
    plt.plot(newTimesteps,newComments,color='maroon',label='Comentários')
    plt.plot(newTimesteps,newLoves,color='magenta',label='Amaram')
    plt.plot(newTimesteps,newShares,color='limeGreen',label='Compartilharam')
    plt.plot(newTimesteps,newSads,color='blue',label='Tristeza')
    plt.plot(newTimesteps,newAngrys,color='red',label='Raiva')
    plt.plot(newTimesteps,newHahas,color='seaGreen',label='Sorriram')
    plt.plot(newTimesteps,newCares,color='orange',label='Se importam')

    plt.xlabel('Timestep')
    plt.ylabel('Quantidade')
    plt.title(str(chartTitleReaction))
    plt.legend()
    plt.savefig('05_meteoro_face_Reacoes.png')
    fig1.show()

    fig2, ax = plt.subplots(figsize=(10 , 5), constrained_layout=True)
    plt.setp(ax.get_xticklabels(), rotation=30, ha="right")
    plt.rcParams.update({'font.size': 12})
    plt.rc('axes', titlesize=24)

    plt.plot(newTimesteps,newLikes,color='purple',label='Infectados (Curtidas)')
    plt.plot(newTimesteps,newComments,color='lightBlue',label='Recuperados (Comentários)')
    plt.plot(newTimesteps,newAsymptContaminated,color='darkOliveGreen',label='Contaminados assintomáticos (Curtidas - comentários)')
    plt.plot(newTimesteps,newAllReactions,color='limeGreen',label='Contaminados sintomáticos (Reações)')

    tex = "Seguidores(suscetíveis):\n " + "320000"
    ax.text(5, 150, tex, fontsize=12, va='center', color="blue")

    plt.xlabel('Timestep')
    plt.ylabel('Quantidade')
    plt.title(str(chartTitleSenseMake))
    plt.legend()

    fig2.tight_layout()

    plt.savefig('04_meteoro_face_Sensemaking.png')
    fig2.show()

    fig3, ax = plt.subplots(figsize=(10 , 5), constrained_layout=True)
    plt.setp(ax.get_xticklabels(), rotation=30, ha="right")
    plt.rcParams.update({'font.size': 12})
    plt.rc('axes', titlesize=24)

    plt.plot(newTimesteps,newComments,color='maroon',label='Comentários')
    plt.plot(newTimesteps,newShares,color='limeGreen',label='Compartilhamentos')
    plt.plot(newTimesteps,newAllReactions,color='magenta',label='Reações')

    print("\nGRÁFICO DE REAÇÕES 2: ")
    print("\nsoma de reações: ",newAllReactions)
    print("\ncomentarios: ",newComments)
    print("\ncompartilhamentos: ",newShares)
    print("\nvisualizações: ",newPostViews)


    plt.xlabel('Timestep')
    plt.ylabel('Quantidade')
    plt.title(str(chartTitleReaction))
    plt.legend()

    fig3.tight_layout()

    plt.savefig('05_meteoro_face_Sentimentos.png')
    fig3.show()

    fig4, ax = plt.subplots(figsize=(10 , 5), constrained_layout=True)
    plt.setp(ax.get_xticklabels(), rotation=30, ha="right")
    plt.rcParams.update({'font.size': 12})
    plt.rc('axes', titlesize= 24)
    # Alterar tamanho da fonte dos labels do eixo X
    plt.xticks(fontsize=6)

    plt.plot(newTimesDates,newComments,color='maroon',label='Comentários')
    plt.plot(newTimesDates,newShares,color='limeGreen',label='Compartilhamentos')
    plt.plot(newTimesDates,newAllReactions,color='magenta',label='Reações')

    plt.xlabel('Timestep')
    plt.ylabel('Quantidade')
    plt.title(str(chartTitleReaction))
    plt.legend()

    fig4.tight_layout()
    fig4.show()

    plt.savefig('05_meteoro_face_Sentimentos_new.png')

print("\nGráfico construido com sucesso!\n\n")

# chartTitleReaction = input("Informe o título do gráfico de reações: ")
# chartTitleSenseMake = input("Informe o título do gráfico de sentimentos: ")
# followings = int(input("Informe o número de seguidores: "))
chartTitleReaction = "Quantidade de reações mensagem Meteoro"
chartTitleSenseMake = "Sensemaking mensagem Meteoro"

csvFilePath = r'post.csv'
jsonFilePath = r'data_meteoro_face.json'
csv_to_json(csvFilePath, jsonFilePath)

# 06 Experimento 02 Meteoro Reaçoes X (Twitter) Coleta manual
# 07 Experimento 02 Meteoro Sensemaking X (Twitter) Coleta manual
# MESMO CODIGO Figura 06 E 07

import matplotlib.pyplot as plt
import matplotlib.pyplot as plt
import csv
import json

def csv_to_json(csvFilePath, jsonFilePath):
    jsonArray = []

    #read csv file
    with open(csvFilePath, encoding='utf-8') as csvf:
        #load csv file data using csv library's dictionary readerreações- 24 Set
        csvReader = csv.DictReader(csvf)

        #convert each csv row into python dict
        for row in csvReader:
            #add this python dict to json array
            jsonArray.insert(0, row)

    #convert python jsonArray to JSON String and write to file
    with open(jsonFilePath, 'w', encoding='utf-8') as jsonf:
        jsonString = json.dumps(jsonArray, indent=4)
        jsonf.write(jsonString)

    def getTimeStep(data):
        step = data["Timestep"]
        return int(step)

    def getLikes(data):
        likes = data["Likes"]
        return int(likes)

    def getComments(data):
        comment = data["Comments"]
        return int(comment)

    def getShares(data):
        shares = data["Shares"]
        return int(shares)

    def getTotalViews(data):
        views = data["Total Views"]
        return int(views)

    def getAsymptContaminated(data):
        likes = data["Likes"]
        shares = data["Shares"]
        return int(int(likes) - int(shares))

    def getSymptomaticContaminated(data):
        shares = data["Shares"]
        return int(shares)

    newTimesteps = list(map(getTimeStep, jsonArray))
    newLikes = list(map(getLikes, jsonArray))
    newComments = list(map(getComments, jsonArray))
    newShares = list(map(getShares, jsonArray))
    newPostViews = list(map(getTotalViews, jsonArray))
    newAsymptContaminated = list(map(getAsymptContaminated,jsonArray))
    newSymptContaminated = list(map(getSymptomaticContaminated,jsonArray))

    # Build chart
    fig1, ax = plt.subplots(figsize=(10 , 5), constrained_layout=True)
    plt.setp(ax.get_xticklabels(), rotation=30, ha="right")
    plt.rcParams.update({'font.size': 10})
    plt.rc('axes', titlesize=24)

    plt.plot(newTimesteps,newLikes,color='blue',label='Curtidas')
    plt.plot(newTimesteps,newComments,color='maroon',label='Comentários')
    plt.plot(newTimesteps,newShares,color='limeGreen',label='Compartilharam')

    plt.xlabel('Dias')
    plt.ylabel('Quantidade')
    plt.title(str(chartTitleReaction))
    plt.legend()

    fig1.show()
    plt.savefig('06_Exp_02_Meteoro_X_Twitter_Reacoes.png')

    fig2, ax = plt.subplots(figsize=(10 , 5), constrained_layout=True)
    plt.setp(ax.get_xticklabels(), rotation=30, ha="right")
    plt.rcParams.update({'font.size': 10})
    plt.rc('axes', titlesize=24)

    plt.plot(newTimesteps,newLikes,color='red',label='Infectados (Curtidas + Compartilhamentos)')
    plt.plot(newTimesteps,newComments,color='lightBlue',label='Recuperados (Comentários)')
    plt.plot(newTimesteps,newAsymptContaminated,color='darkOliveGreen',label='Contaminados assintomáticos (Curtidas - compartilhamentos)')
    plt.plot(newTimesteps,newSymptContaminated,color='pink',label='Contaminados sintomáticos (compartilhamentos)')

    tex = "Visualizações \n1º dia(suscetíveis):\n " + str(newPostViews[0])
    ax.text(5, 150, tex, fontsize=10, va='center', color="blue")

    plt.xlabel('Dias')
    plt.ylabel('Quantidade')
    plt.title(str(chartTitleSenseMake))
    plt.legend()

    fig2.tight_layout()
    fig2.show()
    plt.savefig('07_Exp_02_Meteoro_X_Twitter_Sensemaking.png')

print("\nGráfico construido com sucesso!\n\n")

# chartTitleReaction = input("Informe o título do gráfico de reações: ")
# chartTitleSenseMake = input("Informe o título do gráfico de sentimentos: ")
# followings = int(input("Informe o número de seguidores: "))
chartTitleReaction = "Quantidade de reações mensagem Meteoro - X (Twitter)"
chartTitleSenseMake = "Sensemaking mensagem Meteoro - X (Twitter)"

csvFilePath = r'ANALISE TWITTER.csv'
jsonFilePath = r'data_meteoro_tw.json'
csv_to_json(csvFilePath, jsonFilePath)

# 08 Experimento 02 Meteoro X (Twitter) Coleta manual Projeção Modelo SIR
# 08_Exp_02_Meteoro_X_Twitter_Projeção_SIR_Pt_Fig_08
# Figura 08
#pacotes necessário para análise

from scipy.integrate import odeint
import numpy as np
import plotly.graph_objects as go
import numpy as np #para algum cálculo. Você pode querer usar seu módulo favorito para isso, como estatísticas

#Parâmetros para gerar a solução:
# **NOVA MENSAGEM TWITTER E CROWNDTANGLE
# https://twitter.com/GloboNews/status/1753237488687026336?s=20
# GloboNews
# A Nasa informou que um asteroide quase do tamanho do est dio do Maracan  est  se aproximando da Terra.
# Ele foi classificado pela Ag ncia Espacial americana como potencialmente perigoso.

N = 8817    # população total
i0 = 61       # número inicial de infectados
r0 = 12         # número inicial de recuperados
s0 = N - i0 - r0

#gera um vetor (0,1,2,3..,179) que representa o valores de t usados para gerar a solução.
t = np.arange(start=1, stop=31, step=1)

beta = 247 / (8 * 100)
# Achar taxa de contaminação beta
# Quantidade de infectados no útimo dia (247 likes e compartilhamntos)/ (quantidade de dias   8 X 100)


gama = 49 / (8 * 100)
# Achar taxa de recuperação gama
# Quantidade de recuperados no útimo dia (49 comentários)/ (quantidade de dias 8 X 100)

#Solução numérica do modelo SIR
def SIR(t,beta,gama,N, i0,r0):
    def dotSIR(y,t,beta,gama,N): # função que define o sistema de EDO's
      S,I,R = y # # y é o vetor com as 3 equações S,I,R

      #Formular matemática do SIR em :  https://scipython.com/book/chapter-8-scipy/additional-examples/the-sir-epidemic-model/
      # Aqui as equações em Python:
      #vetor em que cada elemento é uma das equações
      dydt = [
         -beta*S*I/N,
         beta*S*I/N - gama*I,
         gama*I
         ]

      return dydt

    y0 = [s0,i0,r0] #vetor que armazena as condições iniciais do sistema


    #O comando responsável por encontrar a solução numérica é o odeint
    # O comando retorna uma matriz com as colunas determinadas pelo número de equações, nesse caso 3
    # e com o número de linhas referentes ao intervalo de tempo considerado.
    sol = odeint(dotSIR, y0,t, args=(beta,gama,N))


    # a primeira coluna da matriz sol é referente aos Suscetíves, que é a primeira equação do sistema.
    S = sol[:,0]

    # a segunda coluna da matriz é referente aos Infectados, que é a segunda equação do sistema.
    I = sol[:,1]

    # a terceira coluna da matriz é referente aos Recuperados, que é a terceira equação do sistema.
    R = sol[:,2]

    #variável que armazena a soma dos Infectados + Recuperados com o tempo para podermos analisar o
    #valor acumulado de pessoas infectadas no decorrer do tempo
    C = sol[:, 1] + sol[:,2]

    return S,I,R,C

#variável que armazenará S,I,R,C que são os valores retornados pela função SIR,
solucao = SIR(t,beta,gama,N, i0,r0)
#como a função retorna um array com cada elemento sendo S,I,R,C para analisar cada solução separadamente
#vamos definir as seguintes variáveis
S = solucao[0]  #Suscetíves
I = solucao[1]  #Infectados
R = solucao[2]  #Recuperados
C = solucao[3]  #Casos Acumulados
infectInt = I.astype('int32')

#cada uma das variáveis trace abaixo armazena o conjunto de pontos gerada pela função SIR que queremos plotar.
#Veja que como queremos plotar 4 conjuntos de dados diferentes S,I,R,C armazenamos cada um deles em uma varíavel.
trace1 = go.Scatter(x=t, y=S, mode='lines', name='Suscetível', line_shape='spline')
trace2 = go.Scatter(x=t, y=I, mode='lines+markers+text', name='Infectado', line_shape='spline', text=infectInt)
trace3 = go.Scatter(x=t, y=R, mode='lines', name='Recuperado', line_shape='spline')
trace4 = go.Scatter(x=t, y=C, mode='lines', name='Casos acumulados', line_shape='spline')

layout = go.Layout(
    title={
        'text': '<b>SIR MODEL</b>   -   Twitter mensagem sobre o Meteoro' +
                '              ' + 'Beta = ' + str(beta) + '   Gama = ' + str(gama),
        'font': {'family': 'Arial', 'size': 20, 'color': '#7f7f7f'}
    },
    xaxis={'title': 'Dias', 'tickfont': {'family': 'Arial', 'size': 20, 'color': '#7f7f7f'}},
    yaxis={'title': 'População', 'tickfont': {'family': 'Arial', 'size': 20, 'color': '#7f7f7f'}}
)

data = [trace1, trace2, trace3, trace4]

fig = go.Figure(data, layout=layout)
fig.update_traces(textposition="bottom right")

fig.update_layout(
    legend_orientation="h",
    legend=dict(y=-0.30),
    font=dict(size=8)
)

fig.show() #mostra a figura

# 09 Experimento 03 API Youtube Dia 1 Projeção Modelo SI/SIR
# Figura 09
# Figura 10
# Figura 11
# Figura 12
# Figura 13
# Figura 14

# 09 Youtube dia 1 projeção SI / SIR
# Projeto-SIR-App-X - v3/apiYouTube.py

import json
from scipy.integrate import odeint
import numpy as np
import plotly.graph_objects as go

newTimesteps = []
newRecovered = []
newSusceptible = []
newInfectious = []
newSymptomaticContaminated = []
newAsymptContaminated = []
newInfectiousAgent = []

initialSusceptible: int = 0
gammaRate:float = 0.0
betaRate:float = 0.0

infectName = ""
symptName = ""
infectAgentName = ""


def carregar_json(caminho_arquivo):

    try:
        with open(caminho_arquivo, "r", encoding="utf-8") as arquivo:
            dados = json.load(arquivo)  # Converte o conteúdo do arquivo para um objeto Python
            return dados
    except FileNotFoundError:
        print(f"Error: The file '{caminho_arquivo}' not found.")
    except json.JSONDecodeError:
        print(f"Erro: The file '{caminho_arquivo}' does not contain a valid JSON.")

#Projeto-SIR-App-X - v3/HN21Fs3_0UM_estatistica.json

apiObject = carregar_json("HN21Fs3_0UM_estatistica.json")

def getViews():
    return int(apiObject["statistics"]["items"][0]["statistics"]["viewCount"])

def getLikes():
    return int(apiObject["statistics"]["items"][0]["statistics"]["likeCount"])

def getComments():
    return int(apiObject["statistics"]["items"][0]["statistics"]["commentCount"])

def getTopComments():
    comments = apiObject["comments"]["items"]
    textComments = list(map(lambda comment: comment["snippet"]["topLevelComment"]["snippet"]["textOriginal"],comments))
    return textComments

def getBetaRate(S0, I0, I1, N, t):
    print("\nChoose an option:")
    print("1 - Calculate the approximate beta rate")
    print("2 - Enter the beta rate manually")

    chooseRateMode = int(input("\nEnter your choice (1 or 2): "))

    if chooseRateMode == 1:

        if I1 <= I0:
            raise ValueError("The number of infected I1 must be greater than I0.")

        beta = (np.log(I1 / I0) * N) / (S0 * t )
    else:
        beta =float(input("Beta rate:"))


    return beta

def getGammaRate(delta_R, I0, I1, delta_t):

    print("\nChoose an option:")
    print("1 - Calculate approximate gamma rate")
    print("2 - Enter the gamma rate manually")

    chooseRateMode = int(input("\nEnter your choice (1 or 2): "))

    if chooseRateMode == 1:
        I_mean = (I0 + I1) / 2

        # Calculates the recovery rate
        gamma = delta_R / (I_mean * delta_t)
    else:
        gamma =  float(input("\nEnter gamma rate: "))

    return gamma

def SIR(t,beta,gamma,N, i0,r0):
    def dotSIR(y,t,beta,gama,N):
      S,I,R = y
      dydt = [
         -beta*S*I/N,
         beta*S*I/N - gama*I,
         gama*I
         ]

      return dydt

    s0 = N - i0 - r0
    y0 = [s0,i0,r0]
    sol = odeint(dotSIR, y0,t, args=(beta,gamma,N))

    S = sol[:,0]
    I = sol[:,1]
    R = sol[:,2]

    return S,I,R

def generateSirCharts(colecDays:int):

    delta_R = newRecovered[-2]
    i0 = 1
    i1 = newRecovered[-2] + newInfectious[-2]
    gammaRate = getGammaRate(delta_R, i0, i1, colecDays)
    s0 = newSusceptible[-1]
    N = newSusceptible[-1] + 1
    betaRate = getBetaRate(s0,i0,i1,N,colecDays)

    timeCount = len(newTimesteps) + 1
    t = np.arange(start=0, stop=timeCount , step=1)
    r0 = 0

    S,I,R = SIR(t,betaRate,gammaRate,N, i0,r0)

    infectIntSir = I.astype('int32')
    suscepIntSir = S.astype('int32')
    recoveredIntSir = R.astype('int32')

    # SIR - MAKE CHART
    trace1Sir = go.Scatter(
        x=t,
        y=S,
        mode='lines+markers+text',
        name='Susceptible',
        line=dict(color='blue', width=1),
        line_shape='spline',
        text=suscepIntSir,
        textposition='top center',
        textfont=dict(
            size=8,
            color='blue'
        )
    )

    trace2Sir = go.Scatter(
        x=t,
        y=I,
        mode='lines+markers+text',
        name= f"Infected ({infectName})",
        line_shape='spline',
        text= infectIntSir,
        textposition='bottom center',
        textfont=dict(
            size=8,
            color='red'
            )
    )

    trace3Sir = go.Scatter(
        x=t,
        y=R,
        mode='lines+markers+text',
        name= f"Recovered",
        text=recoveredIntSir,
        textposition='bottom center',
            textfont=dict(
            size=8,
            color='green'
            ),
        line=dict(color='green', width=1),
        line_shape='spline',
    )

    dataSir=[trace1Sir,trace2Sir,trace3Sir]

    figSir = go.Figure(dataSir)

    figSir.update_layout(
        title = '<b>SIR MODEL</b> - Projection: '+ ' Gamma(recovery)=' +
        str(round(gammaRate, 4)) + ', Beta (transmission)=' + str(round(betaRate, 4)) +
        ',  Population=' + str(N),
        legend_orientation="h",
        legend=dict(
            y=-0.30
            ),
        font=dict(
            size=14,
        ))

    figSir.write_image("chart_SIR_project.png", width=1200, height=800, scale=2)
    figSir.show()

def generateInfectCharts():
    # INFECTED CHART:
    trace2 = go.Scatter(
    x=newTimesteps,
    y=newAsymptContaminated,
    mode='lines+markers',
    name=f"A -> Asymptomatic" ,
    line=dict(color='blue', width=1),
    line_shape='spline',
    marker=dict(color="blue")
    )

    array_numpy_asympt = np.array(newAsymptContaminated)
    asymptInt = array_numpy_asympt.astype('int32')

    trace2_texts = go.Scatter(
            x=newTimesteps,
            y=newAsymptContaminated,
            mode="text",
            text= asymptInt,
            textposition="bottom right",
            textfont=dict(
                size=8,
                color="blue",
            ),
            showlegend=False,
        )

    trace3 = go.Scatter(
    x=newTimesteps,
    y=newSymptomaticContaminated,
    mode='lines+markers',
    name=f"S -> Symptomatic ({symptName})" ,
    line=dict(color='purple', width=1),
    line_shape='spline',
    marker=dict(color="purple")
    )

    array_numpy_sympt = np.array(newSymptomaticContaminated)
    symptInt = array_numpy_sympt.astype('int32')

    trace3_texts = go.Scatter(
            x=newTimesteps,
            y=newSymptomaticContaminated,
            mode="text",
            text= symptInt,
            textposition="bottom right",
            textfont=dict(
                size=8,
                color="purple",
            ),
            showlegend=False,
        )

    trace4 = go.Scatter(
    x=newTimesteps,
    y=newInfectiousAgent,
    mode='lines+markers',
    name=f"II -> infectious Agent ({infectAgentName})" ,
    line=dict(color='red', width=1),
    line_shape='spline',
    marker=dict(color="red")
    )

    array_numpy_sympt_agent = np.array(newInfectiousAgent)
    symptAgentInt = array_numpy_sympt_agent.astype('int32')

    trace4_texts = go.Scatter(
            x=newTimesteps,
            y=newInfectiousAgent,
            mode="text",
            text= symptAgentInt,
            textposition="top center",
            textfont=dict(
                size=8,
                color="red",
            ),
            showlegend=False,
        )

    data=[trace2, trace2_texts, trace3, trace3_texts, trace4, trace4_texts]
    fig1 = go.Figure(data)

    fig1.update_layout(
        title={
            "text": "<b>Infected chart</b>",
            "font": {'family': 'Arial', 'size': 24, 'color': 'red'}
        },
        legend_orientation="h",
        legend=dict(y=-0.30, x=0, orientation="v"),
        font=dict(size=18, color="gray"),
        xaxis=dict(tickangle=-45 )
    )
    fig1.show()


def calcular_si(S0, I0, beta, N, t_max, dt):
    def dotSI(y, t, beta, N):
        S, I = y
        dS_dt = -beta * S * I / N
        dI_dt = beta * S * I / N
        return [dS_dt, dI_dt]

    t = np.arange(0, t_max + dt, dt)
    y0 = [S0, I0]
    sol = odeint(dotSI, y0, t, args=(beta, N))
    S = sol[:, 0]
    I = sol[:, 1]

    return t, S, I

def plot_si(t, S, I, N):

    infectIntSir = I.astype('int32')
    suscepIntSir = S.astype('int32')

    # SI - MAKE CHART
    trace1Si = go.Scatter(
        x=t,
        y=S,
        mode='lines+markers+text',
        name=f'Susceptible',
        line=dict(color='blue', width=1),
        line_shape='spline',
        text=suscepIntSir,
        textposition='top center',
        textfont=dict(
            size=8,
            color='blue'
        )
    )

    trace2Si = go.Scatter(
        x=t,
        y=I,
        mode='lines+markers+text',
        name= f"Infected ({infectName})",
        line_shape='spline',
        text= infectIntSir,
        textposition='bottom center',
        textfont=dict(
            size=8,
            color='red'
            )
    )

    dataSir=[trace1Si,trace2Si]

    figSir = go.Figure(dataSir)

    figSir.update_layout(
        title = '<b>SI MODEL</b> - Projection ->  Beta(Transmission rate)=' + str(betaRate) +
        ',  Population=' + str(N),
        legend_orientation="h",
        template="plotly_white",
        legend=dict(
            y=-0.30
            ),
        font=dict(
            size=14,
        ))

    figSir.show()



def generateSiChart(days: int, colecDays: int, infec: int, suscep: int):
    global betaRate
    I1 = infec
    N = suscep + 1
    S0 = suscep
    I0 = 1
    betaRate = getBetaRate(S0, I0, I1, N, colecDays)
    t_max = days
    dt = 1
    t, S, I = calcular_si(S0, I0, betaRate, N, t_max, dt)

    plot_si(t, S, I, N)


def runScript():
    global newTimesteps
    global newRecovered
    global newInfectious
    global newSusceptible
    global initialSusceptible
    global newAsymptContaminated
    global newSymptomaticContaminated
    global newInfectiousAgent
    global infectName
    global symptName
    global infectAgentName

    print(f"\nviews: {getViews()}")
    print(f"comments: {getComments()}")
    print(f"top comments: {len(getTopComments())}")
    print(f"likes: {getLikes()}\n")

    choose = int(input("Choose your model\n SIR - Enter 1 \n SI - Enter 2\n"))

    print("Enter the correct parameter option: \n1 - views \n2 - Likes \n3 - Comments \n4 - Top Comments")
    infectious = int(input("Option for Infected: "))
    symptomaticContaminated = int(input("Symptomatic contaminated option: "))
    infectiousAgent = int(input("Infectious agent option: "))

    if infectious == 1:
        infectious = getViews()
        infectName = "views"
    elif infectious == 2:
        infectious = getLikes()
        infectName = "likes"
    elif infectious == 3:
        infectious = getComments()
        infectName = "comments"
    elif recover == 4:
        recover = len(getTopComments)
        infectName = "top comments"
    else:
        print(" Invalid option")

    if symptomaticContaminated == 1:
        symptomaticContaminated = getViews()
        symptName = "views"
    elif symptomaticContaminated == 2:
        symptomaticContaminated = getLikes()
        symptName = "likes"
    elif symptomaticContaminated == 3:
        symptomaticContaminated = getComments()
        symptName = "comments"
    elif symptomaticContaminated == 4:
        symptomaticContaminated = len(getTopComments())
        symptName = "top comments"
    else:
        print(" Invalid option")


    if infectiousAgent == 1:
        infectiousAgent = getViews()
        infectAgentName = "views"
    elif infectiousAgent == 2:
        infectiousAgent = getLikes()
        infectAgentName = "likes"

    elif infectiousAgent == 3:
        infectiousAgent = getComments()
        infectAgentName = "comments"
    elif infectiousAgent == 4:
        infectiousAgent = len(getTopComments())
        infectAgentName = "top comments"
    else:
        print(" Invalid option")

    numDays = int(input("Number of days for the projection: "))
    colectDataDays = int(input("Number of days of data collection: "))

    for i in range(numDays):
        newTimesteps.append(i)

    newInfectious.append(infectious)
    newInfectious.append(0)

    newAsymptContaminated.append(0)
    newAsymptContaminated.append(infectious - symptomaticContaminated)

    newSymptomaticContaminated.append(0)
    newSymptomaticContaminated.append(symptomaticContaminated)

    newInfectiousAgent.append(0)
    newInfectiousAgent.append(infectiousAgent)

    initialSusceptible = int(input("Number of susceptible: "))

    if choose == 1:
        recover = int(input("Recovered option: "))
        if recover == 1:
            recover = getViews()
        elif recover == 2:
            recover = getLikes()
        elif recover == 3:
            recover = getComments()
        elif recover == 4:
            recover = len(getTopComments())
        else:
            print(" Invalid option")

        newSusceptible.append(initialSusceptible - infectious - recover)
        newSusceptible.append(initialSusceptible)

        newRecovered.append(recover)
        newRecovered.append(0)

        generateInfectCharts()
        generateSirCharts(colectDataDays)

    else:
        newSusceptible.append(initialSusceptible - infectious)
        newSusceptible.append(initialSusceptible)
        generateInfectCharts()
        generateSiChart(days=numDays, colecDays=colectDataDays, infec=infectious,suscep=initialSusceptible)


runScript()



# 10_ssc_projecao_entrada_manual.py
# "SSC_SIR Adaptado_Projeçao.ipynb"
# rascunho da sugestao de modelo SIR adaptado
# onde considerariamos algumas pessoas susceptíveis (S) nunca são infectadas,
# mas migram diretamente para os recuperados (R) — como se fossem naturalmente resistentes ou imunizadas espontaneamente.
# Para isso, adicionamos uma nova taxa, digamos ßr (ou delta), que representa a taxa de migração direta de S para R sem passar por I (conceitualmente Influenciados).
# Como ficaria uma nova Fórmula Matemática do Modelo Modificado (SIR com Resistentes/Imunes)

# Resumo:
# Este código implementa uma simulação epidemiológica baseada em um modelo SIR adaptado, que inclui uma taxa de "resistência direta" (βR), ou seja, indivíduos suscetíveis que se tornam imunes diretamente sem passar pela infecção. O modelo divide a população em três grupos: Suscetíveis (S), Infectados (I) e Recuperados/Imunes (R), e calcula a evolução desses grupos ao longo do tempo com base em taxas definidas pelo usuário:
#   - β (beta): taxa de infecção;
#   - γ (gamma): taxa de recuperação dos infectados;
#   - βR (delta ou betaResist): taxa de imunização direta dos suscetíveis.

# O sistema é resolvido numericamente por meio da integração de equações diferenciais ordinárias (EDOs) com o método `odeint`. O resultado é visualizado em um gráfico interativo usando Plotly.

# Modelo matemático (SIR com resistência direta):
#     dS/dt = -βSI/N - βR·S
#     dI/dt = βSI/N - γI
#     dR/dt = γI + βR·S

# versão 01/08/2025


import numpy as np
from scipy.integrate import odeint
import plotly.graph_objects as go

print("Bem-vindo ao SSC - Modelo SIR Adaptado - Projeção!\n")

# Entrada dos parâmetros pelo usuário
N = int(input("Número total de pessoas na população N: "))
I0 = int(input("Número inicial de sugestionados (infectados): "))
R0 = int(input("Número inicial de críticos (recuperados/imunes): "))
betaRateInf = float(input("Taxa de infecção - β (Beta): "))
gammaRate = float(input("Taxa de recuperação - γ (Gamma): "))
betaRateResist = float(input("Taxa de resistência-imune - βR (Delta): "))
numDays = int(input("Número de dias para a projeção: "))

# Calcula o número inicial de suscetíveis
S0 = N - I0 - R0

# Define o sistema de equações diferenciais (modelo SIR com resistência direta)
def deriv(y, t, N, beta, gamma, betaR):
    S, I, R = y
    dSdt = -beta * S * I / N - betaR * S      # Suscetíveis diminuem por infecção e por resistência direta
    dIdt = beta * S * I / N - gamma * I       # Infectados aumentam por infecção e diminuem por recuperação
    dRdt = gamma * I + betaR * S              # Recuperados aumentam por cura e por resistência direta
    return dSdt, dIdt, dRdt

# Cria um vetor de tempo com numDays pontos (de 0 até numDays-1)
t = np.linspace(0, numDays, numDays)

# Define o estado inicial do sistema: (Suscetíveis, Infectados, Recuperados)
y0 = S0, I0, R0

# Resolve numericamente as equações diferenciais
ret = odeint(deriv, y0, t, args=(N, betaRateInf, gammaRate, betaRateResist))
S, I, R = ret.T  # Transpõe a matriz de saída para separar as curvas S, I e R


# Preparar valores formatados para exibição
infectTextSir = [f"{round(val)}" for val in I]
suscepTextSir = [f"{round(val)}" for val in S]
recoveredTextSir = [f"{round(val)}" for val in R]


# Gráfico para Suscetíveis
trace1Sir = go.Scatter(
    x=t, y=S, mode='lines+markers+text',
    name='Suscetíveis',
    line=dict(color='blue', width=1),
    line_shape='spline',
    text=suscepTextSir,
    textposition='top center',
    textfont=dict(size=8, color='blue')
)

# Gráfico para Infectados
trace2Sir = go.Scatter(
    x=t, y=I, mode='lines+markers+text',
    name="Sugestionados (Infectados)",
    line_shape='spline',
    text=infectTextSir,
    textposition='top center',
    textfont=dict(size=8, color='red')
)

# Gráfico para Recuperados
trace3Sir = go.Scatter(
    x=t, y=R, mode='lines+markers+text',
    name="Críticos",
    line=dict(color='green', width=1),
    line_shape='spline',
    text=recoveredTextSir,
    textposition='bottom center',
    textfont=dict(size=8, color='green')
)

# Criar a figura
fig = go.Figure([trace1Sir, trace2Sir, trace3Sir])

# Configurações do layout do gráfico
fig.update_layout(
    title=(
        f'<b>SSC - SIR ADAPTADO</b> - Projeção: Gamma (γ) = {gammaRate:.10f} '
        f'Beta (β) = {betaRateInf:.10f} Beta imune (βR) = {betaRateResist:.10f} <br> População = {N}'
    ),
    legend_orientation="h",
    legend=dict(y=-0.3),
    font=dict(size=10)
)

# Exibe o gráfico no navegador
fig.show()

print("Suscetíveis (S): ", S)
print("Sugestionados (Infectados) (I): ", I)
print("Críticos (Recuperados/Imunes) (R): ", R)





# 11 v2
## 11 Youtube - SSC leitura planilha excel, coleta de dados. PRINT TABELA DIÁRIA
#11_analise_dados_ssc.py
# Ler de: content/estatistica_youtube_SSC.xlsx
# Grava em: content/analise_ssc_data.json

# 1 - Collecting and analyzing data, generating rates and analysis charts.
# Fazer upload do arquivo de dados coletados da midia social e atualizar o caminho do arquivo na maquina linha "exelPath ="


# 1 - Collecting and analyzing data, generating rates and analysis charts.

# 2 -  Planilhas:
# estatistica_facebook_SSC.xlsx
# estatistica_facebook_Yanomami_SSC.xlsx
# estatistica_X_SSC.xlsx
# estatistica_youtube_SSC.xlsx

# versão 02/08/2025 - ajustada

import numpy as np
import pandas as pd
import plotly.graph_objects as go
import math
import json

# Variáveis globais para armazenar os dados
jsonArray = []

# ====== FUNÇÕES DE ESTIMATIVA ======

def estimar_gama_normalizado(I, R, delta_t):
    gamas, dias = [], []
    for t in range(len(I) - 1):
        delta_r = R[t + 1] - R[t]
        i_medio = (I[t + 1] + I[t]) / 2
        if i_medio > 0:
            gamma_t = delta_r / (i_medio * delta_t)
            gamas.append(gamma_t)
            dias.append(t + 1)

    print("\n📘 Tabela de taxas por dia - Gamma")
    print("Dia\tGamma")
    for dia, taxa in zip(dias, gamas):
        print(f"{dia}\t{taxa:.10f}")

    return np.mean(gamas) if gamas else 0.0

def estimar_beta_normalizado(S, I, R, delta_t):
    betas, dias = [], []
    for t in range(len(I) - 1):
        delta_i = I[t + 1] - I[t]
        delta_r = R[t + 1] - R[t]
        s_medio = (S[t + 1] + S[t]) / 2
        i_medio = (I[t + 1] + I[t]) / 2
        if s_medio > 0 and i_medio > 0:
            beta_t = (delta_i + delta_r) / (s_medio * i_medio * delta_t)
            betas.append(beta_t)
            dias.append(t + 1)

    print("\n📕 Tabela de taxas por dia - Beta")
    print("Dia\tBeta")
    for dia, taxa in zip(dias, betas):
        print(f"{dia}\t{taxa:.10f}")

    return np.mean(betas) if betas else 0.0

def estimar_beta_Imunes_normalizado(S, C, delta_t):
    betas, dias = [], []
    for t in range(len(C) - 1):
        delta_c = C[t + 1] - C[t]
        s_medio = (S[t + 1] + S[t]) / 2
        c_medio = (C[t + 1] + C[t]) / 2
        if s_medio > 0 and c_medio > 0:
            beta_t = delta_c / (s_medio * c_medio * delta_t)
            betas.append(beta_t)
            dias.append(t + 1)

    print("\n📗 Tabela de taxas por dia - Beta Resistente")
    print("Dia\tBeta Resistente")
    for dia, taxa in zip(dias, betas):
        print(f"{dia}\t{taxa:.10f}")

    return np.mean(betas) if betas else 0.0

# ====== FUNÇÕES DE LEITURA E PROCESSAMENTO ======

def convert_excel_to_json(excel_path, sheet_name="Página1", output_path="output.json"):
    global jsonArray
    df = pd.read_excel(excel_path, sheet_name=sheet_name)
    df = df.astype(str)
    jsonList = df.to_dict(orient="records")
    jsonArray = [{k: str(int(float(v))) if v.replace(".", "", 1).isdigit() else v for k, v in row.items()} for row in jsonList]
    with open(output_path, "w", encoding="utf-8") as f:
        json.dump(jsonArray, f, ensure_ascii=False, indent=4)

def safe_convert_to_number(value):
    try:
        return 0 if math.isnan(float(value)) else int(float(value))
    except:
        return 0

def getCustomTableValue(data, key):
    return safe_convert_to_number(data[key])

def getSusceptible(data):
    return safe_convert_to_number(data["Suscetiveis"])

def getTableKeys(data):
    return list(data[0].keys())

# ====== GERAÇÃO DE GRÁFICOS ======

def gerar_trace(nome, x, y, cor, text_position="top center", text_color=None):
    return go.Scatter(
        x=x,
        y=y,
        name=nome,
        mode='lines+markers+text',
        line=dict(color=cor, shape='spline', smoothing=1.3),
        text=[f"<span style='color:{text_color}'>{val}</span>" if text_color else str(val) for val in y],
        textposition=text_position,
        textfont=dict(size=10),
        hoverinfo='name+x+y'
    )

def gerar_grafico(timesteps, suscetiveis, infectados, recuperados, imunes, beta, gamma, betaR):
    layout = go.Layout(
        title={
            "text": f"<b>SSC</b> - Taxas médias: Gamma(γ)={gamma:.10f}, Beta(β)={beta:.10f}, Beta imune(βᵣ)={betaR:.10f}, suscetíveis: {suscetiveis[0]}",
            "font": {"size": 16}
        },
        xaxis={"title": "Dias"},
        yaxis={"title": "População"},
    )

    traces = [
        gerar_trace("Suscetíveis", timesteps, suscetiveis, 'blue', text_position="bottom center", text_color="blue"),
        gerar_trace("Sugestionado", timesteps, infectados, 'red', text_position="bottom center", text_color="red"),
        gerar_trace("Críticos", timesteps, recuperados, 'green', text_position="top center", text_color="green")
    ]
    traces2 = [
        gerar_trace("Sugestionados", timesteps, infectados, 'red', text_position="bottom center", text_color="red"),
        gerar_trace("Críticos", timesteps, recuperados, 'green', text_position="bottom center", text_color="green"),
    ]

    fig = go.Figure(data=traces, layout=layout)
    fig2 = go.Figure(data=traces2, layout=layout)

    fig.show()
    fig2.show()

# ====== EXECUÇÃO PRINCIPAL ======

def runScript():
    print("\n📊 SSC - Análise de planilha e extração de taxas aproximadas")
    excel_path = "estatistica_facebook_SSC.xlsx"
    convert_excel_to_json(excel_path)

    keys = getTableKeys(jsonArray)
    for i, k in enumerate(keys):
        print(f"{i}: {k}")

    i_inf = int(input("Índice da coluna Sugestionados: "))
    i_rec = int(input("Índice da coluna Críticos: "))
    i_imu = int(input("Índice da coluna Imune: "))

    I = [getCustomTableValue(d, keys[i_inf]) for d in jsonArray]
    R = [getCustomTableValue(d, keys[i_rec]) for d in jsonArray]
    C = [getCustomTableValue(d, keys[i_imu]) for d in jsonArray]
    S = [getSusceptible(d) for d in jsonArray]
    T = list(range(len(S)))

    beta = estimar_beta_normalizado(S, I, R, delta_t=1)
    gamma = estimar_gama_normalizado(I, R, delta_t=1)
    betaR = estimar_beta_Imunes_normalizado(S, C, delta_t=1)

    print("\nGráfico construido com sucesso!\n\n")
    print("\nGRÁFICO SSC:\n ")

    print("\nSuscetiveis: ",S)
    print("\nSugestionados: ",I)
    print("\nCríticos: ",R)
    print("\nImunes: ",C)

    print(f"\nTaxa beta: {beta:.10f}")
    print(f"\nTaxa gamma:  {gamma:.10f}")
    print(f"\nTaxa beta imune: {betaR:.10f}\n")

    gerar_grafico(T, S, I, R, C, beta, gamma, betaR)

if __name__ == "__main__":
    runScript()

# 12 Experimento 04 04 Modelo SIR Projecao.ipynb

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint

# Função do modelo SIR
def sir_model(y, t, beta, gamma):
    S, I, R = y
    dSdt = -beta * S * I
    dIdt = beta * S * I - gamma * I
    dRdt = gamma * I
    return [dSdt, dIdt, dRdt]

# Função de simulação e visualização
def simular_SIR(S0, I0, R0, beta, gamma, dias=60):
    t = np.linspace(0, dias, 300)
    solution = odeint(sir_model, [S0, I0, R0], t, args=(beta, gamma))
    S, I, R = solution.T

    plt.figure(figsize=(10, 6))
    plt.plot(t, S, label='Suscetíveis', color='blue')
    plt.plot(t, I, label='Infectados', color='red')
    plt.plot(t, R, label='Recuperados', color='green')
    plt.xlabel('Tempo (dias)')
    plt.ylabel('Número de usuários')
    plt.title(f'Simulação Modelo SIR - β={beta}, γ={gamma}')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

# Entrada de dados
if __name__ == "__main__":
    print("=== Simulador do Modelo SIR ===")
    S0 = int(input("Digite o número inicial de suscetíveis (S0): "))
    I0 = int(input("Digite o número inicial de infectados (I0): "))
    R0 = int(input("Digite o número inicial de recuperados (R0): "))
    beta = float(input("Digite a taxa de infecção (β): "))
    gamma = float(input("Digite a taxa de recuperação (γ): "))
    dias = int(input("Digite o número de dias para simulação: "))

    simular_SIR(S0, I0, R0, beta, gamma, dias)

## 14 Youtube Json - SIR leitura planilha excel, coleta de dados.
# 12_analise_dados_sir.py
# Ler de: estatistica_youtube_SIR.xlsx
# Grava em: analise_sir_data.json

# 1 - Collecting and analyzing data, generating rates and analysis charts.
# Fazer upload do arquivo de dados coletados da midia social e atualizar o caminho do arquivo na maquina linha "exelPath ="


import numpy as np
import pandas as pd
import plotly.graph_objects as go
import math
import json
import os

jsonArray = []


def getProximateTax(list):
    items = [1 if x == 0 else x for x in list]
    rates = [np.log(items[i+1]/items[i]) for i in range(len(items)-1)]
    rate_mid = np.mean(rates)
    return rate_mid


# MAIN METHOD
def runScript():
    global newTimesteps
    global newComments
    global newLikes
    global newTotalViews
    global newRecovered
    global newInfectious
    global newSusceptible
    global initialSusceptible
    global infectiousTableNumber
    global recoveredTableNumber
    global gammaRate
    global betaRate
    global keys
    global chooseFlow


    print("SIR - leitura planilha excel, coleta de dados, extrair taxas aproximadas.\n")

    initialSusceptible = int(input("Digite o número inicial de suscetíveis: "))

    print("\nReceber dados.....\n")


    try:

        jsonFilePath = r'analise_sir_data.json'
        #criar o arquivo json se não existir
        if not os.path.exists(jsonFilePath):
            with open(jsonFilePath, "w", encoding="utf-8") as f:
                json.dump([], f)


        exelPath = r'estatistica_youtube_SIR.xlsx'
        convert_excel_to_json(excel_path=exelPath, output_path=jsonFilePath)

        # Garante que o arquivo foi criado antes de tentar abrir
        if not os.path.exists(jsonFilePath):
            raise FileNotFoundError(f"O arquivo {jsonFilePath} não foi criado. Verifique se o Excel existe e está correto.")

        jsonArray.clear()
        with open(jsonFilePath, "r", encoding="utf-8") as f:
            jsonArray.extend(json.load(f))

        print("""
                \nPara realizarmos a análise, precisamos que você nos forneça algumas informações
                sobre a tabela na planilha: estatistica_youtube_SIR.xlsx em termos de a que
                    cada coluna se refere.\n
                """)

        keys = getTableKeys(jsonArray)
        for indice, elemento in enumerate(keys):
            print(f"Digite {indice} -->  coluna: [ {elemento} ]")


        infectiousTableNumber = int(input("Infectados I : "))
        recoveredTableNumber = int(input("Recuperado R : "))

        newRecovered = list(map(lambda item: getCustomTableValue(item, keys[recoveredTableNumber]), jsonArray))
        newInfectious = list(map(lambda item: getCustomTableValue(item, keys[infectiousTableNumber]), jsonArray))

        newTimesteps = list(map(getTimeStep, jsonArray))
        newSusceptible = list(map(lambda item: getSusceptible(item, keys), jsonArray))
        newComments = list(map(getComments, jsonArray))
        newLikes = list(map(getLikes, jsonArray))
        newTotalViews = list(map(getTotalViews, jsonArray))

        generateStatisticCharts()

    except FileNotFoundError as e:
        print(f"Erro: {e}")
        print("Verifique se o arquivo Excel existe e está no caminho correto.")
    except ValueError as e:
        print(f"Erro: {e}")
        runScript()


def convert_excel_to_json(excel_path, sheet_name="Página1", output_path="output.json"):
    try:
        df = pd.read_excel(excel_path, sheet_name=sheet_name)
        df = df.astype(str)
        json_data = df.to_json(orient="records", indent=4)
        jsonList = df.to_dict(orient="records")


        for row in jsonList:
            row_corrigido = {}
            for chave, valor in row.items():
                if valor.replace(".", "", 1).isdigit():  # Verifica se é um número (com ou sem ponto)
                    row_corrigido[chave] = str(int(float(valor)))  # Remove ponto decimal
                else:
                    row_corrigido[chave] = valor  # Mantém valores não numéricos
            jsonArray.insert(0,row_corrigido)

        # Save JSON
        with open(output_path, "w", encoding="utf-8") as json_file:
            json_file.write(json_data)


    except Exception as e:
        print(f"Erro ao processar o arquivo: {e}")


def safe_convert_to_number(value):
    try:
        num = int(value)
        res = 0 if math.isnan(num) else num
        return res
    except (ValueError, TypeError):
        return int(0)

def getCustomTableValue(data , tableKey:str):
    value = data[tableKey]
    return safe_convert_to_number(value)

def getTimeStep(data):
    step = data["Timestep"]
    return int(step)

def getTimeDate(data):
    date = data["publishedAt"]
    return date

def getLikes(data):
    likes = data["likeCount"]
    return int(likes)

def getComments(data):
    comment = data["commentCount"]
    return int(comment)

def getTotalViews(data):
    views = data["viewCount"]
    return int(views)


def getTableKeys(data):
    return list(data[0].keys())

def getSusceptible(data , keys: list):
    totalInfec = data[keys[infectiousTableNumber]]
    totalRecover = data[keys[recoveredTableNumber]]
    n = initialSusceptible
    s = int(n) -  int(totalRecover) - int(totalInfec)

    return s

def generateStatisticCharts():
    global gammaRate
    global betaRate

    gammaRate = getProximateTax(newRecovered)
    betaRate = getProximateTax(newInfectious)

    layout = go.Layout(
    title={
        "text": '<b>SIR</b> - Taxas aproximadas: gamma: ' + str(round(gammaRate, 4)) +
                ', beta transmissão: ' + str(round(betaRate, 4)),
        "font": {"size": 14}
    },
    xaxis={
        'title': 'Dias',
        'tickfont': {'size': 12}  # <-- tamanho da fonte do eixo X
    },
    yaxis={
        'title': 'População',
        'tickfont': {'size': 12}  # <-- tamanho da fonte do eixo Y
    },
)

    array_numpy_suscept = np.array(newSusceptible)
    susceptInt = array_numpy_suscept.astype('int32')

    trace1 = go.Scatter(
    x=newTimesteps,
    y=newSusceptible,
    mode='lines+markers+text',
    name= f"S - Suscetível, inicial: {initialSusceptible}",
    line=dict(color='blue', width=1),
    line_shape='spline',
    marker=dict(color="blue")
    )


    trace1_texts = go.Scatter(
            x=newTimesteps,
            y=newSusceptible,
            mode="text",
            text= susceptInt,
            textposition="top center",
            textfont=dict(
                size=12,
                color="blue",
            ),
            showlegend=False,
        )


    array_numpy_infect = np.array(newInfectious)
    infectInt = array_numpy_infect.astype('int32')

    trace2 = go.Scatter(
    x=newTimesteps,
    y=newInfectious,
    mode='lines+markers+text',
    name=f"S - Sugestionado - Infectado ('{keys[infectiousTableNumber]}')" ,
    line=dict(color='red', width=1),
    marker=dict(color="red"),
    line_shape='spline'
    )

    trace2_texts = go.Scatter(
            x=newTimesteps,
            y=newInfectious,
            mode="text",
            text= infectInt,
            textposition="bottom center",
            textfont=dict(
                size=12,
                color="red",
            ),
            showlegend=False,
        )


    array_numpy_recov = np.array(newRecovered)
    recovInt = array_numpy_recov.astype('int32')

    trace3 = go.Scatter(
        x=newTimesteps,
        y=newRecovered,
        mode='lines+markers',
        name=f"R - recuperado ('{keys[recoveredTableNumber]}')",
        line=dict(color='green', width=1),
        line_shape='spline',
        marker=dict(color="green")
    )

    trace3_texts = go.Scatter(
        x=newTimesteps,
        y=newRecovered,
        mode="text",
        text=recovInt,
        textposition="top center",

        textfont=dict(
            size=12,
            color="green",
        ),
        showlegend=False,
    )


    data=[trace1, trace1_texts, trace2, trace2_texts, trace3, trace3_texts]

    fig = go.Figure(data, layout = layout)

    fig.update_layout(
    legend_orientation="h",
    legend=dict(
        y=-0.30,
        x=0,
        orientation="v",
        font=dict(size=10)
    ),
    font=dict(size=18, color="gray"),
    xaxis=dict(tickangle=-45 )
)

    # fig.write_html("grafico_estatistica.html")
    # fig.write_image("grafico_estatistica.png", width=1200, height=800, scale=2)

    fig.show()

    print("\nGráfico construido com sucesso!\n\n")
    print("\nGRÁFICO SIR:\n ")
    print("\nlikes: ",newLikes)
    print("\ncomentarios: ",newComments)
    print("\nVisualizações Total: ",newTotalViews)

    print("\nSuscetiveis: ",newSusceptible)
    print("\nRecuperados:",newRecovered)
    print("\n Infectados: ",newInfectious)
    print("\nTaxa gamma: ",gammaRate)
    print("\nTaxa beta: ",betaRate)
    print("\n")


#Main method
runScript()

## 13 Experimento 04 Modelo SIR Retorna as taxas Beta;Gamma ***Planilha qualquer midia
## 13 Youtube - SIR leitura planilha excel, coleta de dados.
# calculo para extrair taxas gama e beta.
#13_analise_dados_ssc.py
# Ler de: content/estatistica_youtube_SSC.xlsx
# Grava em: content/analise_ssc_data.json

# 1 - Collecting and analyzing data, generating rates and analysis charts.
# Fazer upload do arquivo de dados coletados da midia social e atualizar o caminho do arquivo na maquina linha "exelPath ="


# 1 - Collecting and analyzing data, generating rates and analysis charts.

# 1 - Collecting and analyzing data, generating rates and analysis charts.

# 1 - Collecting and analyzing data, generating rates and analysis charts.

import numpy as np
import pandas as pd
import plotly.graph_objects as go
from scipy.integrate import odeint
import math


jsonArray = []


def estimar_gama_normalizado(N, I, R, delta_t):
    """
    Estima a taxa gama (recuperação) usando proporções de infectados e recuperados ao longo do tempo.
    Fórmula: gamma ≈ média de [ (ΔR / (I_médio * Δt)) ]
    """
    # Conversão para proporções
    I_prop = [i / N for i in I]
    R_prop = [r / N for r in R]

    gamas = []
    for t in range(len(I_prop) - 1):
        delta_r = R_prop[t + 1] - R_prop[t]
        i_medio = (I_prop[t + 1] + I_prop[t]) / 2
        if i_medio > 0:
            gamma_t = delta_r / (i_medio * delta_t)
            gamas.append(gamma_t)

    g = sum(gamas) / len(gamas) if gamas else 0.0
    return g / N


def estimar_beta_normalizado(N, S, I, R, delta_t):
    """
    Estima a taxa beta (transmissão) usando proporções de S, I, R ao longo do tempo.
    Fórmula: beta ≈ média de [ (ΔI + ΔR) / (S_médio * I_médio * Δt) ]
    """

        # Conversão para proporções
    I_prop = [i / N for i in I]
    R_prop = [r / N for r in R]
    S_prop = [s / N for s in S]

    betas = []
    for t in range(len(I_prop) - 1):
        delta_i = I_prop[t + 1] - I_prop[t]
        delta_r = R_prop[t + 1] - R_prop[t]
        s_medio = (S_prop[t + 1] + S_prop[t]) / 2
        i_medio = (I_prop[t + 1] + I_prop[t]) / 2
        if s_medio > 0 and i_medio > 0:
            beta_t = (delta_i + delta_r) / (s_medio * i_medio * delta_t)
            betas.append(beta_t)
    b = sum(betas) / len(betas) if betas else 0.0
    return b / N


# MAIN METHOD
def runScript():
    global newTimesteps
    global newRecovered
    global newInfectious
    global newSusceptible
    global initialSusceptible
    global gammaRate
    global betaRate


    print("SIR - leitura planilha excel, coleta de dados, extrair taxas aproximadas.\n")
    print("\nGerando gráfico.....\n")


    try:

        jsonFilePath = r'data.json'
        exelPath = r'estatistica_facebook_SSC.xlsx'
        convert_excel_to_json( excel_path= exelPath, output_path= jsonFilePath)

        newRecovered = list(map(getRecovered, jsonArray))
        newInfectious = list(map(getInfectius, jsonArray))


        newTimesteps = list(map(getTimeStep, jsonArray))
        newSusceptible = list(map(getSusceptible, jsonArray))

        initialSusceptible = newSusceptible[-1]

        generateStatisticCharts()

    except ValueError as e:
        print(f"Erro: {e}")
        runScript()


def convert_excel_to_json(excel_path, sheet_name="Página1", output_path="output.json"):
    try:
        df = pd.read_excel(excel_path, sheet_name=sheet_name)
        df = df.astype(str)
        json_data = df.to_json(orient="records", indent=4)
        jsonList = df.to_dict(orient="records")


        for row in jsonList:
            row_corrigido = {}
            for chave, valor in row.items():
                if valor.replace(".", "", 1).isdigit():  # Verifica se é um número (com ou sem ponto)
                    row_corrigido[chave] = str(int(float(valor)))  # Remove ponto decimal
                else:
                    row_corrigido[chave] = valor  # Mantém valores não numéricos
            jsonArray.insert(0,row_corrigido)

        # Save JSON
        with open(output_path, "w", encoding="utf-8") as json_file:
            json_file.write(json_data)


    except Exception as e:
        print(f"Erro ao processar o arquivo: {e}")


def safe_convert_to_number(value):
    try:
        num = int(value)
        res = 0 if math.isnan(num) else num
        return res
    except (ValueError, TypeError):
        return int(0)


def getTimeStep(data):
    step = data["Timestep"]
    return int(step)

def getTimeDate(data):
    date = data["publishedAt"]
    return date

def getInfectius(data):
    date = data["Sugestionado"]
    return int(date)

def getRecovered(data):
    date = data["Critico"]
    return int(date)

def getSusceptible(data):
    date = data["Suscetiveis"]
    return int(date)


def generateStatisticCharts():
    global gammaRate
    global betaRate
    global criticBetaRate
    global initialSusceptible

    gammaRate = estimar_gama_normalizado(initialSusceptible, newInfectious[::-1], newRecovered[::-1], 1)
    betaRate = estimar_beta_normalizado(initialSusceptible, newSusceptible[::-1], newInfectious[::-1], newRecovered[::-1], 1)

    layout = go.Layout(
    title={
        "text": '<b>SIR</b> - Taxas aproximadas: gamma: ' + str(round(gammaRate, 10)) +
                ', beta transmissão: ' + str(round(betaRate, 10)) +
                ", Suscetíveis: " + str(initialSusceptible),
        "font": {"size": 16}
    },
    xaxis={
        'title': 'Dias',
        'tickfont': {'size': 14}  # <-- tamanho da fonte do eixo X
    },
    yaxis={
        'title': 'População',
        'tickfont': {'size': 14}  # <-- tamanho da fonte do eixo Y
    },
)

    array_numpy_suscept = np.array(newSusceptible)
    susceptInt = array_numpy_suscept.astype('int32')

    trace1 = go.Scatter(
    x=newTimesteps,
    y=newSusceptible,
    mode='lines+markers+text',
    name= f"S - Suscetível, inicial: {initialSusceptible}",
    line=dict(color='blue', width=1),
    line_shape='spline',
    marker=dict(color="blue")
    )


    trace1_texts = go.Scatter(
            x=newTimesteps,
            y=newSusceptible,
            mode="text",
            text= susceptInt,
            textposition="top center",
            textfont=dict(
                size=12,
                color="blue",
            ),
            showlegend=False,
        )


    array_numpy_infect = np.array(newInfectious)
    infectInt = array_numpy_infect.astype('int32')

    trace2 = go.Scatter(
    x=newTimesteps,
    y=newInfectious,
    mode='lines+markers+text',
    name="I - Infectado" ,
    line=dict(color='red', width=1),
    marker=dict(color="red"),
    line_shape='spline'
    )

    trace2_texts = go.Scatter(
            x=newTimesteps,
            y=newInfectious,
            mode="text",
            text= infectInt,
            textposition="bottom center",
            textfont=dict(
                size=12,
                color="red",
            ),
            showlegend=False,
        )


    array_numpy_recov = np.array(newRecovered)
    recovInt = array_numpy_recov.astype('int32')

    trace3 = go.Scatter(
        x=newTimesteps,
        y=newRecovered,
        mode='lines+markers',
        name= "R - Recuperado",
        line=dict(color='green', width=1),
        line_shape='spline',
        marker=dict(color="green")
    )

    trace3_texts = go.Scatter(
        x=newTimesteps,
        y=newRecovered,
        mode="text",
        text=recovInt,
        textposition="top center",

        textfont=dict(
            size=12,
            color="green",
        ),
        showlegend=False,
    )


    data=[trace1, trace1_texts, trace2, trace2_texts, trace3, trace3_texts]
    data2=[trace2, trace2_texts, trace3, trace3_texts]

    fig = go.Figure(data, layout = layout)
    fig2 = go.Figure(data2, layout = layout)

    fig.update_layout(
    legend_orientation="h",
    legend=dict(
        y=-0.30,
        x=0,
        orientation="v",
        font=dict(size=10)
    ),
    font=dict(size=18, color="gray"),
    xaxis=dict(tickangle=-45 )
)

    fig.show()

    print("\nGráfico construido com sucesso!\n\n")
    print("\nGRÁFICO SSC:\n ")

    print("\nSuscetiveis: ",newSusceptible)
    print("\nRecuperados:",newRecovered)
    print("\nInfectados: ",newInfectious)
    print("\nTaxa gamma: ", f"{gammaRate:.10f}")
    print("\nTaxa beta: ",f"{betaRate:.20f}")
    print("\n")

    fig2.show()



#Main method
runScript()

## 14 Youtube Json - SIR leitura planilha excel, coleta de dados.
# 12_analise_dados_sir.py
# Ler de: estatistica_youtube_SIR.xlsx
# Grava em: analise_sir_data.json

# 1 - Collecting and analyzing data, generating rates and analysis charts.
# Fazer upload do arquivo de dados coletados da midia social e atualizar o caminho do arquivo na maquina linha "exelPath ="


import numpy as np
import pandas as pd
import plotly.graph_objects as go
import math
import json
import os

jsonArray = []


def getProximateTax(list):
    items = [1 if x == 0 else x for x in list]
    rates = [np.log(items[i+1]/items[i]) for i in range(len(items)-1)]
    rate_mid = np.mean(rates)
    return rate_mid


# MAIN METHOD
def runScript():
    global newTimesteps
    global newComments
    global newLikes
    global newTotalViews
    global newRecovered
    global newInfectious
    global newSusceptible
    global initialSusceptible
    global infectiousTableNumber
    global recoveredTableNumber
    global gammaRate
    global betaRate
    global keys
    global chooseFlow


    print("SIR - leitura planilha excel, coleta de dados, extrair taxas aproximadas.\n")

    initialSusceptible = int(input("Digite o número inicial de suscetíveis: "))

    print("\nReceber dados.....\n")


    try:

        jsonFilePath = r'analise_sir_data.json'
        #criar o arquivo json se não existir
        if not os.path.exists(jsonFilePath):
            with open(jsonFilePath, "w", encoding="utf-8") as f:
                json.dump([], f)


        exelPath = r'estatistica_youtube_SIR.xlsx'
        convert_excel_to_json(excel_path=exelPath, output_path=jsonFilePath)

        # Garante que o arquivo foi criado antes de tentar abrir
        if not os.path.exists(jsonFilePath):
            raise FileNotFoundError(f"O arquivo {jsonFilePath} não foi criado. Verifique se o Excel existe e está correto.")

        jsonArray.clear()
        with open(jsonFilePath, "r", encoding="utf-8") as f:
            jsonArray.extend(json.load(f))

        print("""
                \nPara realizarmos a análise, precisamos que você nos forneça algumas informações
                sobre a tabela na planilha: estatistica_youtube_SIR.xlsx em termos de a que
                    cada coluna se refere.\n
                """)

        keys = getTableKeys(jsonArray)
        for indice, elemento in enumerate(keys):
            print(f"Digite {indice} -->  coluna: [ {elemento} ]")


        infectiousTableNumber = int(input("Infectados I : "))
        recoveredTableNumber = int(input("Recuperado R : "))

        newRecovered = list(map(lambda item: getCustomTableValue(item, keys[recoveredTableNumber]), jsonArray))
        newInfectious = list(map(lambda item: getCustomTableValue(item, keys[infectiousTableNumber]), jsonArray))

        newTimesteps = list(map(getTimeStep, jsonArray))
        newSusceptible = list(map(lambda item: getSusceptible(item, keys), jsonArray))
        newComments = list(map(getComments, jsonArray))
        newLikes = list(map(getLikes, jsonArray))
        newTotalViews = list(map(getTotalViews, jsonArray))

        generateStatisticCharts()

    except FileNotFoundError as e:
        print(f"Erro: {e}")
        print("Verifique se o arquivo Excel existe e está no caminho correto.")
    except ValueError as e:
        print(f"Erro: {e}")
        runScript()


def convert_excel_to_json(excel_path, sheet_name="Página1", output_path="output.json"):
    try:
        df = pd.read_excel(excel_path, sheet_name=sheet_name)
        df = df.astype(str)
        json_data = df.to_json(orient="records", indent=4)
        jsonList = df.to_dict(orient="records")


        for row in jsonList:
            row_corrigido = {}
            for chave, valor in row.items():
                if valor.replace(".", "", 1).isdigit():  # Verifica se é um número (com ou sem ponto)
                    row_corrigido[chave] = str(int(float(valor)))  # Remove ponto decimal
                else:
                    row_corrigido[chave] = valor  # Mantém valores não numéricos
            jsonArray.insert(0,row_corrigido)

        # Save JSON
        with open(output_path, "w", encoding="utf-8") as json_file:
            json_file.write(json_data)


    except Exception as e:
        print(f"Erro ao processar o arquivo: {e}")


def safe_convert_to_number(value):
    try:
        num = int(value)
        res = 0 if math.isnan(num) else num
        return res
    except (ValueError, TypeError):
        return int(0)

def getCustomTableValue(data , tableKey:str):
    value = data[tableKey]
    return safe_convert_to_number(value)

def getTimeStep(data):
    step = data["Timestep"]
    return int(step)

def getTimeDate(data):
    date = data["publishedAt"]
    return date

def getLikes(data):
    likes = data["likeCount"]
    return int(likes)

def getComments(data):
    comment = data["commentCount"]
    return int(comment)

def getTotalViews(data):
    views = data["viewCount"]
    return int(views)


def getTableKeys(data):
    return list(data[0].keys())

def getSusceptible(data , keys: list):
    totalInfec = data[keys[infectiousTableNumber]]
    totalRecover = data[keys[recoveredTableNumber]]
    n = initialSusceptible
    s = int(n) -  int(totalRecover) - int(totalInfec)

    return s

def generateStatisticCharts():
    global gammaRate
    global betaRate

    gammaRate = getProximateTax(newRecovered)
    betaRate = getProximateTax(newInfectious)

    layout = go.Layout(
    title={
        "text": '<b>SIR</b> - Taxas aproximadas: gamma: ' + str(round(gammaRate, 4)) +
                ', beta transmissão: ' + str(round(betaRate, 4)),
        "font": {"size": 14}
    },
    xaxis={
        'title': 'Dias',
        'tickfont': {'size': 12}  # <-- tamanho da fonte do eixo X
    },
    yaxis={
        'title': 'População',
        'tickfont': {'size': 12}  # <-- tamanho da fonte do eixo Y
    },
)

    array_numpy_suscept = np.array(newSusceptible)
    susceptInt = array_numpy_suscept.astype('int32')

    trace1 = go.Scatter(
    x=newTimesteps,
    y=newSusceptible,
    mode='lines+markers+text',
    name= f"S - Suscetível, inicial: {initialSusceptible}",
    line=dict(color='blue', width=1),
    line_shape='spline',
    marker=dict(color="blue")
    )


    trace1_texts = go.Scatter(
            x=newTimesteps,
            y=newSusceptible,
            mode="text",
            text= susceptInt,
            textposition="top center",
            textfont=dict(
                size=12,
                color="blue",
            ),
            showlegend=False,
        )


    array_numpy_infect = np.array(newInfectious)
    infectInt = array_numpy_infect.astype('int32')

    trace2 = go.Scatter(
    x=newTimesteps,
    y=newInfectious,
    mode='lines+markers+text',
    name=f"S - Sugestionado - Infectado ('{keys[infectiousTableNumber]}')" ,
    line=dict(color='red', width=1),
    marker=dict(color="red"),
    line_shape='spline'
    )

    trace2_texts = go.Scatter(
            x=newTimesteps,
            y=newInfectious,
            mode="text",
            text= infectInt,
            textposition="bottom center",
            textfont=dict(
                size=12,
                color="red",
            ),
            showlegend=False,
        )


    array_numpy_recov = np.array(newRecovered)
    recovInt = array_numpy_recov.astype('int32')

    trace3 = go.Scatter(
        x=newTimesteps,
        y=newRecovered,
        mode='lines+markers',
        name=f"R - recuperado ('{keys[recoveredTableNumber]}')",
        line=dict(color='green', width=1),
        line_shape='spline',
        marker=dict(color="green")
    )

    trace3_texts = go.Scatter(
        x=newTimesteps,
        y=newRecovered,
        mode="text",
        text=recovInt,
        textposition="top center",

        textfont=dict(
            size=12,
            color="green",
        ),
        showlegend=False,
    )


    data=[trace1, trace1_texts, trace2, trace2_texts, trace3, trace3_texts]

    fig = go.Figure(data, layout = layout)

    fig.update_layout(
    legend_orientation="h",
    legend=dict(
        y=-0.30,
        x=0,
        orientation="v",
        font=dict(size=10)
    ),
    font=dict(size=18, color="gray"),
    xaxis=dict(tickangle=-45 )
)

    # fig.write_html("grafico_estatistica.html")
    # fig.write_image("grafico_estatistica.png", width=1200, height=800, scale=2)

    fig.show()

    print("\nGráfico construido com sucesso!\n\n")
    print("\nGRÁFICO SIR:\n ")
    print("\nlikes: ",newLikes)
    print("\ncomentarios: ",newComments)
    print("\nVisualizações Total: ",newTotalViews)

    print("\nSuscetiveis: ",newSusceptible)
    print("\nRecuperados:",newRecovered)
    print("\n Infectados: ",newInfectious)
    print("\nTaxa gamma: ",gammaRate)
    print("\nTaxa beta: ",betaRate)
    print("\n")


#Main method
runScript()

# Modelo SIR Fixo
import numpy as np
from scipy.integrate import odeint
import plotly.graph_objects as go

# 🧮 Parâmetros do modelo
N = 1000            # População total
I0 = 1              # Inicialmente sugestionado (infectado)
R0 = 0              # Inicialmente crítico (recuperado)
S0 = N - I0 - R0    # Suscetíveis no início

beta = 0.3          # Taxa de infecção (influência)
gamma = 0.1         # Taxa de recuperação
dias = 30           # Número de dias da simulação

# 📐 Equações diferenciais do modelo SIR tradicional
def sir(y, t, beta, gamma):
    S, I, R = y
    dSdt = -beta * S * I
    dIdt = beta * S * I - gamma * I
    dRdt = gamma * I
    return dSdt, dIdt, dRdt

# 🧪 Simulação do modelo
def simular_sir(S0, I0, R0, beta, gamma, dias):
    y0 = S0, I0, R0
    t = np.linspace(0, dias, dias)
    resultado = odeint(sir, y0, t, args=(beta, gamma))
    S, I, R = resultado.T
    return t, S, I, R

# 📊 Geração do gráfico
def gerar_grafico():
    t, S, I, R = simular_sir(S0, I0, R0, beta, gamma, dias)

    fig = go.Figure()

    fig.add_trace(go.Scatter(x=t, y=S, mode='lines+markers', name='Suscetíveis', line=dict(color='blue')))
    fig.add_trace(go.Scatter(x=t, y=I, mode='lines+markers', name='Infectados', line=dict(color='red')))
    fig.add_trace(go.Scatter(x=t, y=R, mode='lines+markers', name='Recuerados', line=dict(color='green')))

    fig.update_layout(
        title=f"Modelo SIR Tradicional<br><sup>β={beta}, γ={gamma}, N={N}</sup>",
        xaxis_title="Dias",
        yaxis_title="Número de Pessoas",
        font=dict(size=12),
        legend_orientation="h"
    )

    fig.show()

# ▶️ Executar
gerar_grafico()

#Tentativa modelo SIR Adaptado Fixo
import numpy as np
from scipy.integrate import odeint
import plotly.graph_objects as go

# 🧮 Parâmetros do modelo
N = 1000            # População total
I0 = 1              # Inicialmente sugestionado
R0 = 0              # Inicialmente crítico
S0 = N - I0 - R0    # Suscetíveis no início

beta = 0.3          # Taxa de infecção (influência)
gamma = 0.1         # Taxa de recuperação
beta_r = 0.05       # Taxa de resistência direta (S -> R) --- imune

dias = 30           # Número de dias da simulação

# 📐 Equações diferenciais do modelo SIR adaptado
def sir_resistente(y, t, beta, gamma, beta_r):
    S, I, R = y
    dSdt = -beta * S * I - beta_r * S
    dIdt = beta * S * I - gamma * I
    dRdt = gamma * I + beta_r * S
    return dSdt, dIdt, dRdt

# 🧪 Simulação do modelo
def simular_sir_resistente(S0, I0, R0, beta, gamma, beta_r, dias):
    y0 = S0, I0, R0
    t = np.linspace(0, dias, dias)
    resultado = odeint(sir_resistente, y0, t, args=(beta, gamma, beta_r))
    S, I, R = resultado.T
    return t, S, I, R

# 📊 Geração do gráfico
def gerar_grafico():
    t, S, I, R = simular_sir_resistente(S0, I0, R0, beta, gamma, beta_r, dias)

    fig = go.Figure()

    fig.add_trace(go.Scatter(x=t, y=S, mode='lines+markers', name='Suscetíveis', line=dict(color='blue')))
    fig.add_trace(go.Scatter(x=t, y=I, mode='lines+markers', name='Sugestionados', line=dict(color='red')))
    fig.add_trace(go.Scatter(x=t, y=R, mode='lines+markers', name='Críticos', line=dict(color='green')))

    fig.update_layout(
        title=f"Modelo SIR Adaptado com Resistência Direta<br><sup>β={beta}, γ={gamma}, δ={beta_r}, N={N}</sup>",
        xaxis_title="Dias",
        yaxis_title="Número de Pessoas",
        font=dict(size=12),
        legend_orientation="h"
    )

    fig.show()

# ▶️ Executar
gerar_grafico()

# Exemplo SIR fixo
# import packages
import scipy.integrate
import numpy as np
import matplotlib.pyplot as plt

#ODES
def SIR_model(y, t, beta, gamma):
    S, I, R = y

    dS = -beta*S*I
    dI = beta*S*I - gamma*I
    dR = gamma*I

    return ([dS, dI, dR])

#time vector
t = np.linspace(0, 100,1000)

#Initial condition
S0 = 1000000
I0 = 37000
R0 = 60000
beta = 1.1
gamma = 0.27
Ro = beta/(gamma)
print('R0 =',Ro)

#solution
solution = scipy.integrate.odeint(SIR_model, [S0, I0, R0], t, args=(beta, gamma))


#plot result
plt.figure(figsize=[6,4])
plt.plot(t, solution[:, 0], label="S(t)")
plt.plot(t, solution[:, 1], label="I(t)")
plt.plot(t, solution[:, 2], label="R(t)")
plt.grid()
plt.legend()
plt.xlabel("Time")
plt.ylabel("Proportions")
plt.title("SIR model")
plt.show()

# Exemplo SIRD fixo
# import packages
# SIMULA
# 						        FACEBOOK			X								              YOUTUBE							          SIMULA 01	SIMULA 02	SIMULA 03
# S (Suscetível)		  2740909				5700000							          1680000							          9800		  15000		  1000000
# I (Sugestionado)		1661				  47+14+3 =64						        967+27=994						        100			  200			  37000
# R (Crítico/Resist)	20					  8817- (47 + 14) + 37 = 8793		188416 - (967) + 11= 187460		100			  2000		  60000

import scipy.integrate
import numpy as np
import matplotlib.pyplot as plt

#ODES
def SIRD_model(y, t, beta, gamma, delta):            #adding death separately from recovery
    S, I, R, D = y

    dS = -beta*S*I
    dI = beta*S*I - gamma*I - delta*I
    dR = gamma*I
    dD = delta*I

    return ([dS, dI, dR, dD])

#time vector
t = np.linspace(0, 100,1000)

#Initial condition
S0 = 1000000
I0 = 37000
R0 = 60000
D0 = 0
beta = 0.45
gamma = 0.1
delta = 0.15
Ro = beta/(delta+gamma)
print('R0 =',Ro)

#solution
solution = scipy.integrate.odeint(SIRD_model, [S0, I0, R0, D0], t, args=(beta, gamma, delta))


#plot result
plt.figure(figsize=[6,4])
plt.plot(t, solution[:, 0], label="S(t)")
plt.plot(t, solution[:, 1], label="I(t)")
plt.plot(t, solution[:, 2], label="R(t)")
plt.plot(t, solution[:, 3], label="D(t)")
plt.grid()
plt.legend()
plt.xlabel("Time")
plt.ylabel("Proportions")
plt.title("SIRD model")
plt.show()