# -*- coding: utf-8 -*-
"""Codigos Todos os Experimentos - SSC_SIR Adaptado_Proje√ßao_DadosColetados.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15Sn3y9LihSESCP_Lxic65VIvdVnJpPR6

##### IMPORTANTE **** Para a defesa os codigos novos a serem executados sao os 10 e 11
::: os anteriores foram criados nos primeiros experimentos
"""

# Readme
# IMPORTANTE **** Para a defesa os codigos novos a serem executados sao os 10 11 12::: os anteriores foram criados nos primeiros experimentos
# os c√≥digos estao organizados na seguinte ordem:
# 01 Experimento 01 Yanomami Rea√ßoes Facebook ***Antes da Qualificacao # MESMO CODIGO 01 02
# 02 Experimento 01 Yanomami Sensemaking Facebook ***Antes da Qualificacao # MESMO CODIGO 01 02
# 03 Experimento 02 Meteoro Rea√ßoes Facebook ***Antes da Qualificacao # MESMO CODIGO 03 04
# 04 Experimento 02 Meteoro Sensemaking Facebook ***Antes da Qualificacao # MESMO CODIGO 03 04
# FALTA CRIAR PERDIDO UTILIZAR CODIGO 08 - 05 Experimento 02 Meteoro Facebook Proje√ß√£o Modelo SIR ***PENDENTE
# 06 Experimento 02 Meteoro Rea√ßoes X (Twitter) Coleta manual ***Antes da Qualificacao # MESMO CODIGO Figura 06 E 07
# 07 Experimento 02 Meteoro Sensemaking X (Twitter) Coleta manual ***Antes da Qualificacao # MESMO CODIGO Figura 06 E 07
# 08 Experimento 02 Meteoro X (Twitter) Coleta manual Proje√ß√£o Modelo SIR ***Antes da Qualificacao
# 09 Experimento 03 API Youtube Dia 1 Proje√ß√£o Modelo SI/SIR *CRIADO ANTES DA DEFINICAO DO SIR ADAPTADO
# 10 Experimento 04 API Youtube Dia 1 Proje√ß√£o Modelo SIR Adaptado SSC
# 11 Experimento 04 Modelo SIR Adaptado SSC Retorna as taxas Beta;Gamma;Delta ***Planilha qualquer midia -- por dia
# 12 Experimento 04 Modelo SIR Projecao
# 13 Experimento 04 Modelo SIR Retorna as taxas Beta;Gamma ***Planilha qualquer midia
# 14 Experimento 04 Modelo SIR Retorna as taxas Beta;Gamma ***JSON Youtube
# Tentantivas anteriores
#     Modelo SIR Fixo
#     Tentativa modelo SIR Adaptado Fixo
#     Exemplo OLD SIR fixo
#     Exemplo OLD SIRD fixo

# Versoes
# Vers√£o 2.0 30/07/2025 11 Taxas por dia
# Vers√£o 1.0 23/07/2025 Enviado professores

# ARQUIVOS UPLOAD COLAB - Arquivos disponivel no github https://github.com/RitaNegreiros/RitaNegreiros_Mestrado_Colab.git

# ANALISE TWITTER.csv
# HN21Fs3_OUM_estatistica.json
# analise_sir_data.json
# analise_ssc_data.json
# data.json
# estatistica_X_SSC.xlsx
# estatistica_youtube_SSC.xlsx
# estatistica_facebook_SSC.xlsx
# estatistica_facebook_Yanomami_SSC.xlsx
# post.csv

# 01 Experimento 01 Yanomami Rea√ßoes Facebook
# 02 Experimento 01 Yanomami Sensemaking Facebook

from numpy import zeros, linspace
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.pyplot as plt
import csv
import json

def csv_to_json(csvFilePath, jsonFilePath):
    jsonArray = []

    #read csv file
    with open(csvFilePath, encoding='utf-8') as csvf:
        #load csv file data using csv library's dictionary readerrea√ß√µes- 24 Set
        csvReader = csv.DictReader(csvf)

        #convert each csv row into python dict
        for row in csvReader:
            #add this python dict to json array
            jsonArray.insert(0, row)

    #convert python jsonArray to JSON String and write to file
    with open(jsonFilePath, 'w', encoding='utf-8') as jsonf:
        jsonString = json.dumps(jsonArray, indent=4)
        jsonf.write(jsonString)

    def getTimeStep(data):
        step = data["Timestep"]
        return int(step)

    def getTimeDate(data):
        date = data["Score Date (GMT)"]
        return date

    def getLikes(data):
        likes = data["Likes"]
        return int(likes)

    def getComments(data):
        comment = data["Comments"]
        return int(comment)

    def getLoves(data):
        loves = data["Loves"]
        return int(loves)

    def getShares(data):
        shares = data["Shares"]
        return int(shares)

    def getPostViews(data):
        views = data["Total Views"]
        return int(views)

    def getSads(data):
        sads = data["Sads"]
        return int(sads)

    def getAngrys(data):
        anglys = data["Angrys"]
        return int(anglys)

    def getHaHas(data):
        hahas = data["Hahas"]
        return int(hahas)

    def getCares(data):
        cares = data["Cares"]
        return int(cares)

    def getAllReactions(data):
        likes = data["Likes"]
        loves = data["Loves"]
        cares = data["Cares"]
        hahas = data["Hahas"]
        sads = data["Sads"]
        anglys = data["Angrys"]
        return int(int(likes) +  int(loves) + int(cares) + int(hahas) + int(sads) + int(anglys))

    def getAsymptContaminated(data):
        views = data["Post Views"]
        shares = data["Shares"]
        return int(int(views) - int(shares))

    newTimesDates = list(map(getTimeDate, jsonArray))
    newTimesteps = list(map(getTimeStep, jsonArray))
    newLikes = list(map(getLikes, jsonArray))
    newComments = list(map(getComments, jsonArray))
    newLoves = list(map(getLoves, jsonArray))
    newShares = list(map(getShares, jsonArray))
    newPostViews = list(map(getPostViews, jsonArray))
    newSads = list(map(getSads, jsonArray))
    newAngrys = list(map(getAngrys, jsonArray))
    newHahas = list(map(getHaHas,jsonArray))
    newCares = list(map(getCares,jsonArray))
    newAllReactions = list(map(getAllReactions,jsonArray))
    newAsymptContaminated = list(map(getAsymptContaminated,jsonArray))

    # Build chart
    fig1, ax = plt.subplots(figsize=(10 , 5), constrained_layout=True)
    plt.setp(ax.get_xticklabels(), rotation=30, ha="right")
    plt.rcParams.update({'font.size': 12})
    plt.rc('axes', titlesize=24)

    plt.plot(newTimesteps,newComments,color='maroon',label='Coment√°rios')
    plt.plot(newTimesteps,newShares,color='limeGreen',label='Compartilhamentos')
    plt.plot(newTimesteps,newPostViews,color='blue',label='Visualiza√ß√µes')
    plt.plot(newTimesteps,newAllReactions,color='magenta',label='Rea√ß√µes')

    print("\nGR√ÅFICO DE REA√á√ïES 2: ")
    print("\nsoma de rea√ß√µes: ",newAllReactions)
    print("\ncomentarios: ",newComments)
    print("\ncompartilhamentos: ",newShares)
    print("\nvisualiza√ß√µes: ",newPostViews)


    plt.xlabel('Timestep')
    plt.ylabel('Quantidade')
    plt.title(str(chartTitleReaction))
    plt.legend()

    fig1.tight_layout()

    plt.savefig('fig01_Yanomami_Reacoes.png')
    fig1.show()

    fig2, ax = plt.subplots(figsize=(10 , 5), constrained_layout=True)
    plt.setp(ax.get_xticklabels(), rotation=30, ha="right")
    plt.rcParams.update({'font.size': 12})
    plt.rc('axes', titlesize=24)

    plt.plot(newTimesteps,newPostViews,color='purple',label='Infectados (visualiza√ß√µes)')
    plt.plot(newTimesteps,newAllReactions,color='lightBlue',label='Recuperados (soma de rea√ß√µes)')
    plt.plot(newTimesteps,newAsymptContaminated,color='darkOliveGreen',label='Contaminados assintom√°ticos (visualizaram mas n√£o compartilharam)')
    plt.plot(newTimesteps,newShares,color='limeGreen',label='Contaminados sintom√°ticos (compartilharam)')


    print("\nrecuperados (soma de rea√ß√µes): ",newAllReactions)
    print("\ninfectados (visualiza√ß√µes): ",newPostViews)
    print("\ncontaminados assintom√°ticos (visualizaram mas n√£o compartilharam): ",newAsymptContaminated)
    print("\ncontaminados sintom√°ticos (compartilharam): ",newShares)

    plt.xlabel('Timestep')
    plt.ylabel('Quantidade')
    plt.title(str(chartTitleSenseMake))
    plt.legend()

    tex = "Seguidores:\n " + str(followings)
    ax.text(5, 300, tex, fontsize=16, va='center', color="blue")

    fig2.tight_layout()

    plt.savefig('fig02_Yanomami_Sentimentos.png')
    fig2.show()

print("\nGr√°fico construido com sucesso!\n\n")

# chartTitleReaction = input("Informe o t√≠tulo do gr√°fico de rea√ß√µes: ")
# chartTitleSenseMake = input("Informe o t√≠tulo do gr√°fico de sentimentos: ")
# followings = int(input("Informe o n√∫mero de seguidores: "))
chartTitleReaction = "Quantidade de rea√ß√µes mensagem Yanomami"
chartTitleSenseMake = "Sensemaking mensagem Yanomami"
followings = "2740909"

csvFilePath = r'history_post_6367827886583037.csv'
jsonFilePath = r'yanomami_data.json'
csv_to_json(csvFilePath, jsonFilePath)

# 03 Experimento 02 Meteoro Sensemaking Facebook
# 04 Experimento 02 Meteoro Facebook Proje√ß√£o Modelo SIR
# Figura 04 E 05 MESMO CODIGO 03 04

from numpy import zeros, linspace
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.pyplot as plt
import csv
import json

def csv_to_json(csvFilePath, jsonFilePath):
    jsonArray = []

    #read csv file
    with open(csvFilePath, encoding='utf-8') as csvf:
        #load csv file data using csv library's dictionary readerrea√ß√µes- 24 Set
        csvReader = csv.DictReader(csvf)

        #convert each csv row into python dict
        for row in csvReader:
            #add this python dict to json array
            jsonArray.insert(0, row)

    #convert python jsonArray to JSON String and write to file
    with open(jsonFilePath, 'w', encoding='utf-8') as jsonf:
        jsonString = json.dumps(jsonArray, indent=4)
        jsonf.write(jsonString)

    def getTimeStep(data):
        step = data["Timestep"]
        return int(step)

    def getTimeDate(data):
        date = data["Score Date (GMT)"]
        return date

    def getLikes(data):
        likes = data["Likes"]
        return int(likes)

    def getComments(data):
        comment = data["Comments"]
        return int(comment)

    def getLoves(data):
        loves = data["Loves"]
        return int(loves)

    def getShares(data):
        shares = data["Shares"]
        return int(shares)

    def getPostViews(data):
        views = data["Total Views"]
        return int(views)

    def getSads(data):
        sads = data["Sads"]
        return int(sads)

    def getAngrys(data):
        anglys = data["Angrys"]
        return int(anglys)

    def getHaHas(data):
        hahas = data["Hahas"]
        return int(hahas)

    def getCares(data):
        cares = data["Cares"]
        return int(cares)

    def getAllReactions(data):
        likes = data["Likes"]
        loves = data["Loves"]
        cares = data["Cares"]
        hahas = data["Hahas"]
        sads = data["Sads"]
        anglys = data["Angrys"]
        return int(int(likes) +  int(loves) + int(cares) + int(hahas) + int(sads) + int(anglys))

    def getAsymptContaminated(data):
        likes = data["Likes"]
        comments = data["Comments"]
        return int(int(likes) - int(comments))

    newTimesDates = list(map(getTimeDate, jsonArray))
    newTimesteps = list(map(getTimeStep, jsonArray))
    newLikes = list(map(getLikes, jsonArray))
    newComments = list(map(getComments, jsonArray))
    newLoves = list(map(getLoves, jsonArray))
    newShares = list(map(getShares, jsonArray))
    newPostViews = list(map(getPostViews, jsonArray))
    newSads = list(map(getSads, jsonArray))
    newAngrys = list(map(getAngrys, jsonArray))
    newHahas = list(map(getHaHas,jsonArray))
    newCares = list(map(getCares,jsonArray))
    newAllReactions = list(map(getAllReactions,jsonArray))
    newAsymptContaminated = list(map(getAsymptContaminated,jsonArray))

    # Build chart
    fig1, ax = plt.subplots(figsize=(10 , 5), constrained_layout=True)
    plt.setp(ax.get_xticklabels(), rotation=30, ha="right")
    plt.rcParams.update({'font.size': 12})
    plt.rc('axes', titlesize=24)

    plt.plot(newTimesteps,newLikes,color='green',label='Curtidas')
    plt.plot(newTimesteps,newComments,color='maroon',label='Coment√°rios')
    plt.plot(newTimesteps,newLoves,color='magenta',label='Amaram')
    plt.plot(newTimesteps,newShares,color='limeGreen',label='Compartilharam')
    plt.plot(newTimesteps,newSads,color='blue',label='Tristeza')
    plt.plot(newTimesteps,newAngrys,color='red',label='Raiva')
    plt.plot(newTimesteps,newHahas,color='seaGreen',label='Sorriram')
    plt.plot(newTimesteps,newCares,color='orange',label='Se importam')

    plt.xlabel('Timestep')
    plt.ylabel('Quantidade')
    plt.title(str(chartTitleReaction))
    plt.legend()
    plt.savefig('05_meteoro_face_Reacoes.png')
    fig1.show()

    fig2, ax = plt.subplots(figsize=(10 , 5), constrained_layout=True)
    plt.setp(ax.get_xticklabels(), rotation=30, ha="right")
    plt.rcParams.update({'font.size': 12})
    plt.rc('axes', titlesize=24)

    plt.plot(newTimesteps,newLikes,color='purple',label='Infectados (Curtidas)')
    plt.plot(newTimesteps,newComments,color='lightBlue',label='Recuperados (Coment√°rios)')
    plt.plot(newTimesteps,newAsymptContaminated,color='darkOliveGreen',label='Contaminados assintom√°ticos (Curtidas - coment√°rios)')
    plt.plot(newTimesteps,newAllReactions,color='limeGreen',label='Contaminados sintom√°ticos (Rea√ß√µes)')

    tex = "Seguidores(suscet√≠veis):\n " + "320000"
    ax.text(5, 150, tex, fontsize=12, va='center', color="blue")

    plt.xlabel('Timestep')
    plt.ylabel('Quantidade')
    plt.title(str(chartTitleSenseMake))
    plt.legend()

    fig2.tight_layout()

    plt.savefig('04_meteoro_face_Sensemaking.png')
    fig2.show()

    fig3, ax = plt.subplots(figsize=(10 , 5), constrained_layout=True)
    plt.setp(ax.get_xticklabels(), rotation=30, ha="right")
    plt.rcParams.update({'font.size': 12})
    plt.rc('axes', titlesize=24)

    plt.plot(newTimesteps,newComments,color='maroon',label='Coment√°rios')
    plt.plot(newTimesteps,newShares,color='limeGreen',label='Compartilhamentos')
    plt.plot(newTimesteps,newAllReactions,color='magenta',label='Rea√ß√µes')

    print("\nGR√ÅFICO DE REA√á√ïES 2: ")
    print("\nsoma de rea√ß√µes: ",newAllReactions)
    print("\ncomentarios: ",newComments)
    print("\ncompartilhamentos: ",newShares)
    print("\nvisualiza√ß√µes: ",newPostViews)


    plt.xlabel('Timestep')
    plt.ylabel('Quantidade')
    plt.title(str(chartTitleReaction))
    plt.legend()

    fig3.tight_layout()

    plt.savefig('05_meteoro_face_Sentimentos.png')
    fig3.show()

    fig4, ax = plt.subplots(figsize=(10 , 5), constrained_layout=True)
    plt.setp(ax.get_xticklabels(), rotation=30, ha="right")
    plt.rcParams.update({'font.size': 12})
    plt.rc('axes', titlesize= 24)
    # Alterar tamanho da fonte dos labels do eixo X
    plt.xticks(fontsize=6)

    plt.plot(newTimesDates,newComments,color='maroon',label='Coment√°rios')
    plt.plot(newTimesDates,newShares,color='limeGreen',label='Compartilhamentos')
    plt.plot(newTimesDates,newAllReactions,color='magenta',label='Rea√ß√µes')

    plt.xlabel('Timestep')
    plt.ylabel('Quantidade')
    plt.title(str(chartTitleReaction))
    plt.legend()

    fig4.tight_layout()
    fig4.show()

    plt.savefig('05_meteoro_face_Sentimentos_new.png')

print("\nGr√°fico construido com sucesso!\n\n")

# chartTitleReaction = input("Informe o t√≠tulo do gr√°fico de rea√ß√µes: ")
# chartTitleSenseMake = input("Informe o t√≠tulo do gr√°fico de sentimentos: ")
# followings = int(input("Informe o n√∫mero de seguidores: "))
chartTitleReaction = "Quantidade de rea√ß√µes mensagem Meteoro"
chartTitleSenseMake = "Sensemaking mensagem Meteoro"

csvFilePath = r'post.csv'
jsonFilePath = r'data_meteoro_face.json'
csv_to_json(csvFilePath, jsonFilePath)

# 06 Experimento 02 Meteoro Rea√ßoes X (Twitter) Coleta manual
# 07 Experimento 02 Meteoro Sensemaking X (Twitter) Coleta manual
# MESMO CODIGO Figura 06 E 07

import matplotlib.pyplot as plt
import matplotlib.pyplot as plt
import csv
import json

def csv_to_json(csvFilePath, jsonFilePath):
    jsonArray = []

    #read csv file
    with open(csvFilePath, encoding='utf-8') as csvf:
        #load csv file data using csv library's dictionary readerrea√ß√µes- 24 Set
        csvReader = csv.DictReader(csvf)

        #convert each csv row into python dict
        for row in csvReader:
            #add this python dict to json array
            jsonArray.insert(0, row)

    #convert python jsonArray to JSON String and write to file
    with open(jsonFilePath, 'w', encoding='utf-8') as jsonf:
        jsonString = json.dumps(jsonArray, indent=4)
        jsonf.write(jsonString)

    def getTimeStep(data):
        step = data["Timestep"]
        return int(step)

    def getLikes(data):
        likes = data["Likes"]
        return int(likes)

    def getComments(data):
        comment = data["Comments"]
        return int(comment)

    def getShares(data):
        shares = data["Shares"]
        return int(shares)

    def getTotalViews(data):
        views = data["Total Views"]
        return int(views)

    def getAsymptContaminated(data):
        likes = data["Likes"]
        shares = data["Shares"]
        return int(int(likes) - int(shares))

    def getSymptomaticContaminated(data):
        shares = data["Shares"]
        return int(shares)

    newTimesteps = list(map(getTimeStep, jsonArray))
    newLikes = list(map(getLikes, jsonArray))
    newComments = list(map(getComments, jsonArray))
    newShares = list(map(getShares, jsonArray))
    newPostViews = list(map(getTotalViews, jsonArray))
    newAsymptContaminated = list(map(getAsymptContaminated,jsonArray))
    newSymptContaminated = list(map(getSymptomaticContaminated,jsonArray))

    # Build chart
    fig1, ax = plt.subplots(figsize=(10 , 5), constrained_layout=True)
    plt.setp(ax.get_xticklabels(), rotation=30, ha="right")
    plt.rcParams.update({'font.size': 10})
    plt.rc('axes', titlesize=24)

    plt.plot(newTimesteps,newLikes,color='blue',label='Curtidas')
    plt.plot(newTimesteps,newComments,color='maroon',label='Coment√°rios')
    plt.plot(newTimesteps,newShares,color='limeGreen',label='Compartilharam')

    plt.xlabel('Dias')
    plt.ylabel('Quantidade')
    plt.title(str(chartTitleReaction))
    plt.legend()

    fig1.show()
    plt.savefig('06_Exp_02_Meteoro_X_Twitter_Reacoes.png')

    fig2, ax = plt.subplots(figsize=(10 , 5), constrained_layout=True)
    plt.setp(ax.get_xticklabels(), rotation=30, ha="right")
    plt.rcParams.update({'font.size': 10})
    plt.rc('axes', titlesize=24)

    plt.plot(newTimesteps,newLikes,color='red',label='Infectados (Curtidas + Compartilhamentos)')
    plt.plot(newTimesteps,newComments,color='lightBlue',label='Recuperados (Coment√°rios)')
    plt.plot(newTimesteps,newAsymptContaminated,color='darkOliveGreen',label='Contaminados assintom√°ticos (Curtidas - compartilhamentos)')
    plt.plot(newTimesteps,newSymptContaminated,color='pink',label='Contaminados sintom√°ticos (compartilhamentos)')

    tex = "Visualiza√ß√µes \n1¬∫ dia(suscet√≠veis):\n " + str(newPostViews[0])
    ax.text(5, 150, tex, fontsize=10, va='center', color="blue")

    plt.xlabel('Dias')
    plt.ylabel('Quantidade')
    plt.title(str(chartTitleSenseMake))
    plt.legend()

    fig2.tight_layout()
    fig2.show()
    plt.savefig('07_Exp_02_Meteoro_X_Twitter_Sensemaking.png')

print("\nGr√°fico construido com sucesso!\n\n")

# chartTitleReaction = input("Informe o t√≠tulo do gr√°fico de rea√ß√µes: ")
# chartTitleSenseMake = input("Informe o t√≠tulo do gr√°fico de sentimentos: ")
# followings = int(input("Informe o n√∫mero de seguidores: "))
chartTitleReaction = "Quantidade de rea√ß√µes mensagem Meteoro - X (Twitter)"
chartTitleSenseMake = "Sensemaking mensagem Meteoro - X (Twitter)"

csvFilePath = r'ANALISE TWITTER.csv'
jsonFilePath = r'data_meteoro_tw.json'
csv_to_json(csvFilePath, jsonFilePath)

# 08 Experimento 02 Meteoro X (Twitter) Coleta manual Proje√ß√£o Modelo SIR
# 08_Exp_02_Meteoro_X_Twitter_Proje√ß√£o_SIR_Pt_Fig_08
# Figura 08
#pacotes necess√°rio para an√°lise

from scipy.integrate import odeint
import numpy as np
import plotly.graph_objects as go
import numpy as np #para algum c√°lculo. Voc√™ pode querer usar seu m√≥dulo favorito para isso, como estat√≠sticas

#Par√¢metros para gerar a solu√ß√£o:
# **NOVA MENSAGEM TWITTER E CROWNDTANGLE
# https://twitter.com/GloboNews/status/1753237488687026336?s=20
# GloboNews
# A Nasa informou que um asteroide quase do tamanho do est dio do Maracan  est  se aproximando da Terra.
# Ele foi classificado pela Ag ncia Espacial americana como potencialmente perigoso.

N = 8817    # popula√ß√£o total
i0 = 61       # n√∫mero inicial de infectados
r0 = 12         # n√∫mero inicial de recuperados
s0 = N - i0 - r0

#gera um vetor (0,1,2,3..,179) que representa o valores de t usados para gerar a solu√ß√£o.
t = np.arange(start=1, stop=31, step=1)

beta = 247 / (8 * 100)
# Achar taxa de contamina√ß√£o beta
# Quantidade de infectados no √∫timo dia (247 likes e compartilhamntos)/ (quantidade de dias   8 X 100)


gama = 49 / (8 * 100)
# Achar taxa de recupera√ß√£o gama
# Quantidade de recuperados no √∫timo dia (49 coment√°rios)/ (quantidade de dias 8 X 100)

#Solu√ß√£o num√©rica do modelo SIR
def SIR(t,beta,gama,N, i0,r0):
    def dotSIR(y,t,beta,gama,N): # fun√ß√£o que define o sistema de EDO's
      S,I,R = y # # y √© o vetor com as 3 equa√ß√µes S,I,R

      #Formular matem√°tica do SIR em :  https://scipython.com/book/chapter-8-scipy/additional-examples/the-sir-epidemic-model/
      # Aqui as equa√ß√µes em Python:
      #vetor em que cada elemento √© uma das equa√ß√µes
      dydt = [
         -beta*S*I/N,
         beta*S*I/N - gama*I,
         gama*I
         ]

      return dydt

    y0 = [s0,i0,r0] #vetor que armazena as condi√ß√µes iniciais do sistema


    #O comando respons√°vel por encontrar a solu√ß√£o num√©rica √© o odeint
    # O comando retorna uma matriz com as colunas determinadas pelo n√∫mero de equa√ß√µes, nesse caso 3
    # e com o n√∫mero de linhas referentes ao intervalo de tempo considerado.
    sol = odeint(dotSIR, y0,t, args=(beta,gama,N))


    # a primeira coluna da matriz sol √© referente aos Suscet√≠ves, que √© a primeira equa√ß√£o do sistema.
    S = sol[:,0]

    # a segunda coluna da matriz √© referente aos Infectados, que √© a segunda equa√ß√£o do sistema.
    I = sol[:,1]

    # a terceira coluna da matriz √© referente aos Recuperados, que √© a terceira equa√ß√£o do sistema.
    R = sol[:,2]

    #vari√°vel que armazena a soma dos Infectados + Recuperados com o tempo para podermos analisar o
    #valor acumulado de pessoas infectadas no decorrer do tempo
    C = sol[:, 1] + sol[:,2]

    return S,I,R,C

#vari√°vel que armazenar√° S,I,R,C que s√£o os valores retornados pela fun√ß√£o SIR,
solucao = SIR(t,beta,gama,N, i0,r0)
#como a fun√ß√£o retorna um array com cada elemento sendo S,I,R,C para analisar cada solu√ß√£o separadamente
#vamos definir as seguintes vari√°veis
S = solucao[0]  #Suscet√≠ves
I = solucao[1]  #Infectados
R = solucao[2]  #Recuperados
C = solucao[3]  #Casos Acumulados
infectInt = I.astype('int32')

#cada uma das vari√°veis trace abaixo armazena o conjunto de pontos gerada pela fun√ß√£o SIR que queremos plotar.
#Veja que como queremos plotar 4 conjuntos de dados diferentes S,I,R,C armazenamos cada um deles em uma var√≠avel.
trace1 = go.Scatter(x=t, y=S, mode='lines', name='Suscet√≠vel', line_shape='spline')
trace2 = go.Scatter(x=t, y=I, mode='lines+markers+text', name='Infectado', line_shape='spline', text=infectInt)
trace3 = go.Scatter(x=t, y=R, mode='lines', name='Recuperado', line_shape='spline')
trace4 = go.Scatter(x=t, y=C, mode='lines', name='Casos acumulados', line_shape='spline')

layout = go.Layout(
    title={
        'text': '<b>SIR MODEL</b>   -   Twitter mensagem sobre o Meteoro' +
                '              ' + 'Beta = ' + str(beta) + '   Gama = ' + str(gama),
        'font': {'family': 'Arial', 'size': 20, 'color': '#7f7f7f'}
    },
    xaxis={'title': 'Dias', 'tickfont': {'family': 'Arial', 'size': 20, 'color': '#7f7f7f'}},
    yaxis={'title': 'Popula√ß√£o', 'tickfont': {'family': 'Arial', 'size': 20, 'color': '#7f7f7f'}}
)

data = [trace1, trace2, trace3, trace4]

fig = go.Figure(data, layout=layout)
fig.update_traces(textposition="bottom right")

fig.update_layout(
    legend_orientation="h",
    legend=dict(y=-0.30),
    font=dict(size=8)
)

fig.show() #mostra a figura

# 09 Experimento 03 API Youtube Dia 1 Proje√ß√£o Modelo SI/SIR
# Figura 09
# Figura 10
# Figura 11
# Figura 12
# Figura 13
# Figura 14

# 09 Youtube dia 1 proje√ß√£o SI / SIR
# Projeto-SIR-App-X - v3/apiYouTube.py

import json
from scipy.integrate import odeint
import numpy as np
import plotly.graph_objects as go

newTimesteps = []
newRecovered = []
newSusceptible = []
newInfectious = []
newSymptomaticContaminated = []
newAsymptContaminated = []
newInfectiousAgent = []

initialSusceptible: int = 0
gammaRate:float = 0.0
betaRate:float = 0.0

infectName = ""
symptName = ""
infectAgentName = ""


def carregar_json(caminho_arquivo):

    try:
        with open(caminho_arquivo, "r", encoding="utf-8") as arquivo:
            dados = json.load(arquivo)  # Converte o conte√∫do do arquivo para um objeto Python
            return dados
    except FileNotFoundError:
        print(f"Error: The file '{caminho_arquivo}' not found.")
    except json.JSONDecodeError:
        print(f"Erro: The file '{caminho_arquivo}' does not contain a valid JSON.")

#Projeto-SIR-App-X - v3/HN21Fs3_0UM_estatistica.json

apiObject = carregar_json("HN21Fs3_0UM_estatistica.json")

def getViews():
    return int(apiObject["statistics"]["items"][0]["statistics"]["viewCount"])

def getLikes():
    return int(apiObject["statistics"]["items"][0]["statistics"]["likeCount"])

def getComments():
    return int(apiObject["statistics"]["items"][0]["statistics"]["commentCount"])

def getTopComments():
    comments = apiObject["comments"]["items"]
    textComments = list(map(lambda comment: comment["snippet"]["topLevelComment"]["snippet"]["textOriginal"],comments))
    return textComments

def getBetaRate(S0, I0, I1, N, t):
    print("\nChoose an option:")
    print("1 - Calculate the approximate beta rate")
    print("2 - Enter the beta rate manually")

    chooseRateMode = int(input("\nEnter your choice (1 or 2): "))

    if chooseRateMode == 1:

        if I1 <= I0:
            raise ValueError("The number of infected I1 must be greater than I0.")

        beta = (np.log(I1 / I0) * N) / (S0 * t )
    else:
        beta =float(input("Beta rate:"))


    return beta

def getGammaRate(delta_R, I0, I1, delta_t):

    print("\nChoose an option:")
    print("1 - Calculate approximate gamma rate")
    print("2 - Enter the gamma rate manually")

    chooseRateMode = int(input("\nEnter your choice (1 or 2): "))

    if chooseRateMode == 1:
        I_mean = (I0 + I1) / 2

        # Calculates the recovery rate
        gamma = delta_R / (I_mean * delta_t)
    else:
        gamma =  float(input("\nEnter gamma rate: "))

    return gamma

def SIR(t,beta,gamma,N, i0,r0):
    def dotSIR(y,t,beta,gama,N):
      S,I,R = y
      dydt = [
         -beta*S*I/N,
         beta*S*I/N - gama*I,
         gama*I
         ]

      return dydt

    s0 = N - i0 - r0
    y0 = [s0,i0,r0]
    sol = odeint(dotSIR, y0,t, args=(beta,gamma,N))

    S = sol[:,0]
    I = sol[:,1]
    R = sol[:,2]

    return S,I,R

def generateSirCharts(colecDays:int):

    delta_R = newRecovered[-2]
    i0 = 1
    i1 = newRecovered[-2] + newInfectious[-2]
    gammaRate = getGammaRate(delta_R, i0, i1, colecDays)
    s0 = newSusceptible[-1]
    N = newSusceptible[-1] + 1
    betaRate = getBetaRate(s0,i0,i1,N,colecDays)

    timeCount = len(newTimesteps) + 1
    t = np.arange(start=0, stop=timeCount , step=1)
    r0 = 0

    S,I,R = SIR(t,betaRate,gammaRate,N, i0,r0)

    infectIntSir = I.astype('int32')
    suscepIntSir = S.astype('int32')
    recoveredIntSir = R.astype('int32')

    # SIR - MAKE CHART
    trace1Sir = go.Scatter(
        x=t,
        y=S,
        mode='lines+markers+text',
        name='Susceptible',
        line=dict(color='blue', width=1),
        line_shape='spline',
        text=suscepIntSir,
        textposition='top center',
        textfont=dict(
            size=8,
            color='blue'
        )
    )

    trace2Sir = go.Scatter(
        x=t,
        y=I,
        mode='lines+markers+text',
        name= f"Infected ({infectName})",
        line_shape='spline',
        text= infectIntSir,
        textposition='bottom center',
        textfont=dict(
            size=8,
            color='red'
            )
    )

    trace3Sir = go.Scatter(
        x=t,
        y=R,
        mode='lines+markers+text',
        name= f"Recovered",
        text=recoveredIntSir,
        textposition='bottom center',
            textfont=dict(
            size=8,
            color='green'
            ),
        line=dict(color='green', width=1),
        line_shape='spline',
    )

    dataSir=[trace1Sir,trace2Sir,trace3Sir]

    figSir = go.Figure(dataSir)

    figSir.update_layout(
        title = '<b>SIR MODEL</b> - Projection: '+ ' Gamma(recovery)=' +
        str(round(gammaRate, 4)) + ', Beta (transmission)=' + str(round(betaRate, 4)) +
        ',  Population=' + str(N),
        legend_orientation="h",
        legend=dict(
            y=-0.30
            ),
        font=dict(
            size=14,
        ))

    figSir.write_image("chart_SIR_project.png", width=1200, height=800, scale=2)
    figSir.show()

def generateInfectCharts():
    # INFECTED CHART:
    trace2 = go.Scatter(
    x=newTimesteps,
    y=newAsymptContaminated,
    mode='lines+markers',
    name=f"A -> Asymptomatic" ,
    line=dict(color='blue', width=1),
    line_shape='spline',
    marker=dict(color="blue")
    )

    array_numpy_asympt = np.array(newAsymptContaminated)
    asymptInt = array_numpy_asympt.astype('int32')

    trace2_texts = go.Scatter(
            x=newTimesteps,
            y=newAsymptContaminated,
            mode="text",
            text= asymptInt,
            textposition="bottom right",
            textfont=dict(
                size=8,
                color="blue",
            ),
            showlegend=False,
        )

    trace3 = go.Scatter(
    x=newTimesteps,
    y=newSymptomaticContaminated,
    mode='lines+markers',
    name=f"S -> Symptomatic ({symptName})" ,
    line=dict(color='purple', width=1),
    line_shape='spline',
    marker=dict(color="purple")
    )

    array_numpy_sympt = np.array(newSymptomaticContaminated)
    symptInt = array_numpy_sympt.astype('int32')

    trace3_texts = go.Scatter(
            x=newTimesteps,
            y=newSymptomaticContaminated,
            mode="text",
            text= symptInt,
            textposition="bottom right",
            textfont=dict(
                size=8,
                color="purple",
            ),
            showlegend=False,
        )

    trace4 = go.Scatter(
    x=newTimesteps,
    y=newInfectiousAgent,
    mode='lines+markers',
    name=f"II -> infectious Agent ({infectAgentName})" ,
    line=dict(color='red', width=1),
    line_shape='spline',
    marker=dict(color="red")
    )

    array_numpy_sympt_agent = np.array(newInfectiousAgent)
    symptAgentInt = array_numpy_sympt_agent.astype('int32')

    trace4_texts = go.Scatter(
            x=newTimesteps,
            y=newInfectiousAgent,
            mode="text",
            text= symptAgentInt,
            textposition="top center",
            textfont=dict(
                size=8,
                color="red",
            ),
            showlegend=False,
        )

    data=[trace2, trace2_texts, trace3, trace3_texts, trace4, trace4_texts]
    fig1 = go.Figure(data)

    fig1.update_layout(
        title={
            "text": "<b>Infected chart</b>",
            "font": {'family': 'Arial', 'size': 24, 'color': 'red'}
        },
        legend_orientation="h",
        legend=dict(y=-0.30, x=0, orientation="v"),
        font=dict(size=18, color="gray"),
        xaxis=dict(tickangle=-45 )
    )
    fig1.show()


def calcular_si(S0, I0, beta, N, t_max, dt):
    def dotSI(y, t, beta, N):
        S, I = y
        dS_dt = -beta * S * I / N
        dI_dt = beta * S * I / N
        return [dS_dt, dI_dt]

    t = np.arange(0, t_max + dt, dt)
    y0 = [S0, I0]
    sol = odeint(dotSI, y0, t, args=(beta, N))
    S = sol[:, 0]
    I = sol[:, 1]

    return t, S, I

def plot_si(t, S, I, N):

    infectIntSir = I.astype('int32')
    suscepIntSir = S.astype('int32')

    # SI - MAKE CHART
    trace1Si = go.Scatter(
        x=t,
        y=S,
        mode='lines+markers+text',
        name=f'Susceptible',
        line=dict(color='blue', width=1),
        line_shape='spline',
        text=suscepIntSir,
        textposition='top center',
        textfont=dict(
            size=8,
            color='blue'
        )
    )

    trace2Si = go.Scatter(
        x=t,
        y=I,
        mode='lines+markers+text',
        name= f"Infected ({infectName})",
        line_shape='spline',
        text= infectIntSir,
        textposition='bottom center',
        textfont=dict(
            size=8,
            color='red'
            )
    )

    dataSir=[trace1Si,trace2Si]

    figSir = go.Figure(dataSir)

    figSir.update_layout(
        title = '<b>SI MODEL</b> - Projection ->  Beta(Transmission rate)=' + str(betaRate) +
        ',  Population=' + str(N),
        legend_orientation="h",
        template="plotly_white",
        legend=dict(
            y=-0.30
            ),
        font=dict(
            size=14,
        ))

    figSir.show()



def generateSiChart(days: int, colecDays: int, infec: int, suscep: int):
    global betaRate
    I1 = infec
    N = suscep + 1
    S0 = suscep
    I0 = 1
    betaRate = getBetaRate(S0, I0, I1, N, colecDays)
    t_max = days
    dt = 1
    t, S, I = calcular_si(S0, I0, betaRate, N, t_max, dt)

    plot_si(t, S, I, N)


def runScript():
    global newTimesteps
    global newRecovered
    global newInfectious
    global newSusceptible
    global initialSusceptible
    global newAsymptContaminated
    global newSymptomaticContaminated
    global newInfectiousAgent
    global infectName
    global symptName
    global infectAgentName

    print(f"\nviews: {getViews()}")
    print(f"comments: {getComments()}")
    print(f"top comments: {len(getTopComments())}")
    print(f"likes: {getLikes()}\n")

    choose = int(input("Choose your model\n SIR - Enter 1 \n SI - Enter 2\n"))

    print("Enter the correct parameter option: \n1 - views \n2 - Likes \n3 - Comments \n4 - Top Comments")
    infectious = int(input("Option for Infected: "))
    symptomaticContaminated = int(input("Symptomatic contaminated option: "))
    infectiousAgent = int(input("Infectious agent option: "))

    if infectious == 1:
        infectious = getViews()
        infectName = "views"
    elif infectious == 2:
        infectious = getLikes()
        infectName = "likes"
    elif infectious == 3:
        infectious = getComments()
        infectName = "comments"
    elif recover == 4:
        recover = len(getTopComments)
        infectName = "top comments"
    else:
        print(" Invalid option")

    if symptomaticContaminated == 1:
        symptomaticContaminated = getViews()
        symptName = "views"
    elif symptomaticContaminated == 2:
        symptomaticContaminated = getLikes()
        symptName = "likes"
    elif symptomaticContaminated == 3:
        symptomaticContaminated = getComments()
        symptName = "comments"
    elif symptomaticContaminated == 4:
        symptomaticContaminated = len(getTopComments())
        symptName = "top comments"
    else:
        print(" Invalid option")


    if infectiousAgent == 1:
        infectiousAgent = getViews()
        infectAgentName = "views"
    elif infectiousAgent == 2:
        infectiousAgent = getLikes()
        infectAgentName = "likes"

    elif infectiousAgent == 3:
        infectiousAgent = getComments()
        infectAgentName = "comments"
    elif infectiousAgent == 4:
        infectiousAgent = len(getTopComments())
        infectAgentName = "top comments"
    else:
        print(" Invalid option")

    numDays = int(input("Number of days for the projection: "))
    colectDataDays = int(input("Number of days of data collection: "))

    for i in range(numDays):
        newTimesteps.append(i)

    newInfectious.append(infectious)
    newInfectious.append(0)

    newAsymptContaminated.append(0)
    newAsymptContaminated.append(infectious - symptomaticContaminated)

    newSymptomaticContaminated.append(0)
    newSymptomaticContaminated.append(symptomaticContaminated)

    newInfectiousAgent.append(0)
    newInfectiousAgent.append(infectiousAgent)

    initialSusceptible = int(input("Number of susceptible: "))

    if choose == 1:
        recover = int(input("Recovered option: "))
        if recover == 1:
            recover = getViews()
        elif recover == 2:
            recover = getLikes()
        elif recover == 3:
            recover = getComments()
        elif recover == 4:
            recover = len(getTopComments())
        else:
            print(" Invalid option")

        newSusceptible.append(initialSusceptible - infectious - recover)
        newSusceptible.append(initialSusceptible)

        newRecovered.append(recover)
        newRecovered.append(0)

        generateInfectCharts()
        generateSirCharts(colectDataDays)

    else:
        newSusceptible.append(initialSusceptible - infectious)
        newSusceptible.append(initialSusceptible)
        generateInfectCharts()
        generateSiChart(days=numDays, colecDays=colectDataDays, infec=infectious,suscep=initialSusceptible)


runScript()



# 10_ssc_projecao_entrada_manual.py
# "SSC_SIR Adaptado_Proje√ßao.ipynb"
# rascunho da sugestao de modelo SIR adaptado
# onde considerariamos algumas pessoas suscept√≠veis (S) nunca s√£o infectadas,
# mas migram diretamente para os recuperados (R) ‚Äî como se fossem naturalmente resistentes ou imunizadas espontaneamente.
# Para isso, adicionamos uma nova taxa, digamos √ür (ou delta), que representa a taxa de migra√ß√£o direta de S para R sem passar por I (conceitualmente Influenciados).
# Como ficaria uma nova F√≥rmula Matem√°tica do Modelo Modificado (SIR com Resistentes/Imunes)

# Resumo:
# Este c√≥digo implementa uma simula√ß√£o epidemiol√≥gica baseada em um modelo SIR adaptado, que inclui uma taxa de "resist√™ncia direta" (Œ≤R), ou seja, indiv√≠duos suscet√≠veis que se tornam imunes diretamente sem passar pela infec√ß√£o. O modelo divide a popula√ß√£o em tr√™s grupos: Suscet√≠veis (S), Infectados (I) e Recuperados/Imunes (R), e calcula a evolu√ß√£o desses grupos ao longo do tempo com base em taxas definidas pelo usu√°rio:
#   - Œ≤ (beta): taxa de infec√ß√£o;
#   - Œ≥ (gamma): taxa de recupera√ß√£o dos infectados;
#   - Œ≤R (delta ou betaResist): taxa de imuniza√ß√£o direta dos suscet√≠veis.

# O sistema √© resolvido numericamente por meio da integra√ß√£o de equa√ß√µes diferenciais ordin√°rias (EDOs) com o m√©todo `odeint`. O resultado √© visualizado em um gr√°fico interativo usando Plotly.

# Modelo matem√°tico (SIR com resist√™ncia direta):
#     dS/dt = -Œ≤SI/N - Œ≤R¬∑S
#     dI/dt = Œ≤SI/N - Œ≥I
#     dR/dt = Œ≥I + Œ≤R¬∑S

# vers√£o 01/08/2025


import numpy as np
from scipy.integrate import odeint
import plotly.graph_objects as go

print("Bem-vindo ao SSC - Modelo SIR Adaptado - Proje√ß√£o!\n")

# Entrada dos par√¢metros pelo usu√°rio
N = int(input("N√∫mero total de pessoas na popula√ß√£o N: "))
I0 = int(input("N√∫mero inicial de sugestionados (infectados): "))
R0 = int(input("N√∫mero inicial de cr√≠ticos (recuperados/imunes): "))
betaRateInf = float(input("Taxa de infec√ß√£o - Œ≤ (Beta): "))
gammaRate = float(input("Taxa de recupera√ß√£o - Œ≥ (Gamma): "))
betaRateResist = float(input("Taxa de resist√™ncia-imune - Œ≤R (Delta): "))
numDays = int(input("N√∫mero de dias para a proje√ß√£o: "))

# Calcula o n√∫mero inicial de suscet√≠veis
S0 = N - I0 - R0

# Define o sistema de equa√ß√µes diferenciais (modelo SIR com resist√™ncia direta)
def deriv(y, t, N, beta, gamma, betaR):
    S, I, R = y
    dSdt = -beta * S * I / N - betaR * S      # Suscet√≠veis diminuem por infec√ß√£o e por resist√™ncia direta
    dIdt = beta * S * I / N - gamma * I       # Infectados aumentam por infec√ß√£o e diminuem por recupera√ß√£o
    dRdt = gamma * I + betaR * S              # Recuperados aumentam por cura e por resist√™ncia direta
    return dSdt, dIdt, dRdt

# Cria um vetor de tempo com numDays pontos (de 0 at√© numDays-1)
t = np.linspace(0, numDays, numDays)

# Define o estado inicial do sistema: (Suscet√≠veis, Infectados, Recuperados)
y0 = S0, I0, R0

# Resolve numericamente as equa√ß√µes diferenciais
ret = odeint(deriv, y0, t, args=(N, betaRateInf, gammaRate, betaRateResist))
S, I, R = ret.T  # Transp√µe a matriz de sa√≠da para separar as curvas S, I e R


# Preparar valores formatados para exibi√ß√£o
infectTextSir = [f"{round(val)}" for val in I]
suscepTextSir = [f"{round(val)}" for val in S]
recoveredTextSir = [f"{round(val)}" for val in R]


# Gr√°fico para Suscet√≠veis
trace1Sir = go.Scatter(
    x=t, y=S, mode='lines+markers+text',
    name='Suscet√≠veis',
    line=dict(color='blue', width=1),
    line_shape='spline',
    text=suscepTextSir,
    textposition='top center',
    textfont=dict(size=8, color='blue')
)

# Gr√°fico para Infectados
trace2Sir = go.Scatter(
    x=t, y=I, mode='lines+markers+text',
    name="Sugestionados (Infectados)",
    line_shape='spline',
    text=infectTextSir,
    textposition='top center',
    textfont=dict(size=8, color='red')
)

# Gr√°fico para Recuperados
trace3Sir = go.Scatter(
    x=t, y=R, mode='lines+markers+text',
    name="Cr√≠ticos",
    line=dict(color='green', width=1),
    line_shape='spline',
    text=recoveredTextSir,
    textposition='bottom center',
    textfont=dict(size=8, color='green')
)

# Criar a figura
fig = go.Figure([trace1Sir, trace2Sir, trace3Sir])

# Configura√ß√µes do layout do gr√°fico
fig.update_layout(
    title=(
        f'<b>SSC - SIR ADAPTADO</b> - Proje√ß√£o: Gamma (Œ≥) = {gammaRate:.10f} '
        f'Beta (Œ≤) = {betaRateInf:.10f} Beta imune (Œ≤R) = {betaRateResist:.10f} <br> Popula√ß√£o = {N}'
    ),
    legend_orientation="h",
    legend=dict(y=-0.3),
    font=dict(size=10)
)

# Exibe o gr√°fico no navegador
fig.show()

print("Suscet√≠veis (S): ", S)
print("Sugestionados (Infectados) (I): ", I)
print("Cr√≠ticos (Recuperados/Imunes) (R): ", R)





# 11 v2
## 11 Youtube - SSC leitura planilha excel, coleta de dados. PRINT TABELA DI√ÅRIA
#11_analise_dados_ssc.py
# Ler de: content/estatistica_youtube_SSC.xlsx
# Grava em: content/analise_ssc_data.json

# 1 - Collecting and analyzing data, generating rates and analysis charts.
# Fazer upload do arquivo de dados coletados da midia social e atualizar o caminho do arquivo na maquina linha "exelPath ="


# 1 - Collecting and analyzing data, generating rates and analysis charts.

# 2 -  Planilhas:
# estatistica_facebook_SSC.xlsx
# estatistica_facebook_Yanomami_SSC.xlsx
# estatistica_X_SSC.xlsx
# estatistica_youtube_SSC.xlsx

# vers√£o 02/08/2025 - ajustada

import numpy as np
import pandas as pd
import plotly.graph_objects as go
import math
import json

# Vari√°veis globais para armazenar os dados
jsonArray = []

# ====== FUN√á√ïES DE ESTIMATIVA ======

def estimar_gama_normalizado(I, R, delta_t):
    gamas, dias = [], []
    for t in range(len(I) - 1):
        delta_r = R[t + 1] - R[t]
        i_medio = (I[t + 1] + I[t]) / 2
        if i_medio > 0:
            gamma_t = delta_r / (i_medio * delta_t)
            gamas.append(gamma_t)
            dias.append(t + 1)

    print("\nüìò Tabela de taxas por dia - Gamma")
    print("Dia\tGamma")
    for dia, taxa in zip(dias, gamas):
        print(f"{dia}\t{taxa:.10f}")

    return np.mean(gamas) if gamas else 0.0

def estimar_beta_normalizado(S, I, R, delta_t):
    betas, dias = [], []
    for t in range(len(I) - 1):
        delta_i = I[t + 1] - I[t]
        delta_r = R[t + 1] - R[t]
        s_medio = (S[t + 1] + S[t]) / 2
        i_medio = (I[t + 1] + I[t]) / 2
        if s_medio > 0 and i_medio > 0:
            beta_t = (delta_i + delta_r) / (s_medio * i_medio * delta_t)
            betas.append(beta_t)
            dias.append(t + 1)

    print("\nüìï Tabela de taxas por dia - Beta")
    print("Dia\tBeta")
    for dia, taxa in zip(dias, betas):
        print(f"{dia}\t{taxa:.10f}")

    return np.mean(betas) if betas else 0.0

def estimar_beta_Imunes_normalizado(S, C, delta_t):
    betas, dias = [], []
    for t in range(len(C) - 1):
        delta_c = C[t + 1] - C[t]
        s_medio = (S[t + 1] + S[t]) / 2
        c_medio = (C[t + 1] + C[t]) / 2
        if s_medio > 0 and c_medio > 0:
            beta_t = delta_c / (s_medio * c_medio * delta_t)
            betas.append(beta_t)
            dias.append(t + 1)

    print("\nüìó Tabela de taxas por dia - Beta Resistente")
    print("Dia\tBeta Resistente")
    for dia, taxa in zip(dias, betas):
        print(f"{dia}\t{taxa:.10f}")

    return np.mean(betas) if betas else 0.0

# ====== FUN√á√ïES DE LEITURA E PROCESSAMENTO ======

def convert_excel_to_json(excel_path, sheet_name="P√°gina1", output_path="output.json"):
    global jsonArray
    df = pd.read_excel(excel_path, sheet_name=sheet_name)
    df = df.astype(str)
    jsonList = df.to_dict(orient="records")
    jsonArray = [{k: str(int(float(v))) if v.replace(".", "", 1).isdigit() else v for k, v in row.items()} for row in jsonList]
    with open(output_path, "w", encoding="utf-8") as f:
        json.dump(jsonArray, f, ensure_ascii=False, indent=4)

def safe_convert_to_number(value):
    try:
        return 0 if math.isnan(float(value)) else int(float(value))
    except:
        return 0

def getCustomTableValue(data, key):
    return safe_convert_to_number(data[key])

def getSusceptible(data):
    return safe_convert_to_number(data["Suscetiveis"])

def getTableKeys(data):
    return list(data[0].keys())

# ====== GERA√á√ÉO DE GR√ÅFICOS ======

def gerar_trace(nome, x, y, cor, text_position="top center", text_color=None):
    return go.Scatter(
        x=x,
        y=y,
        name=nome,
        mode='lines+markers+text',
        line=dict(color=cor, shape='spline', smoothing=1.3),
        text=[f"<span style='color:{text_color}'>{val}</span>" if text_color else str(val) for val in y],
        textposition=text_position,
        textfont=dict(size=10),
        hoverinfo='name+x+y'
    )

def gerar_grafico(timesteps, suscetiveis, infectados, recuperados, imunes, beta, gamma, betaR):
    layout = go.Layout(
        title={
            "text": f"<b>SSC</b> - Taxas m√©dias: Gamma(Œ≥)={gamma:.10f}, Beta(Œ≤)={beta:.10f}, Beta imune(Œ≤·µ£)={betaR:.10f}, suscet√≠veis: {suscetiveis[0]}",
            "font": {"size": 16}
        },
        xaxis={"title": "Dias"},
        yaxis={"title": "Popula√ß√£o"},
    )

    traces = [
        gerar_trace("Suscet√≠veis", timesteps, suscetiveis, 'blue', text_position="bottom center", text_color="blue"),
        gerar_trace("Sugestionado", timesteps, infectados, 'red', text_position="bottom center", text_color="red"),
        gerar_trace("Cr√≠ticos", timesteps, recuperados, 'green', text_position="top center", text_color="green")
    ]
    traces2 = [
        gerar_trace("Sugestionados", timesteps, infectados, 'red', text_position="bottom center", text_color="red"),
        gerar_trace("Cr√≠ticos", timesteps, recuperados, 'green', text_position="bottom center", text_color="green"),
    ]

    fig = go.Figure(data=traces, layout=layout)
    fig2 = go.Figure(data=traces2, layout=layout)

    fig.show()
    fig2.show()

# ====== EXECU√á√ÉO PRINCIPAL ======

def runScript():
    print("\nüìä SSC - An√°lise de planilha e extra√ß√£o de taxas aproximadas")
    excel_path = "estatistica_facebook_SSC.xlsx"
    convert_excel_to_json(excel_path)

    keys = getTableKeys(jsonArray)
    for i, k in enumerate(keys):
        print(f"{i}: {k}")

    i_inf = int(input("√çndice da coluna Sugestionados: "))
    i_rec = int(input("√çndice da coluna Cr√≠ticos: "))
    i_imu = int(input("√çndice da coluna Imune: "))

    I = [getCustomTableValue(d, keys[i_inf]) for d in jsonArray]
    R = [getCustomTableValue(d, keys[i_rec]) for d in jsonArray]
    C = [getCustomTableValue(d, keys[i_imu]) for d in jsonArray]
    S = [getSusceptible(d) for d in jsonArray]
    T = list(range(len(S)))

    beta = estimar_beta_normalizado(S, I, R, delta_t=1)
    gamma = estimar_gama_normalizado(I, R, delta_t=1)
    betaR = estimar_beta_Imunes_normalizado(S, C, delta_t=1)

    print("\nGr√°fico construido com sucesso!\n\n")
    print("\nGR√ÅFICO SSC:\n ")

    print("\nSuscetiveis: ",S)
    print("\nSugestionados: ",I)
    print("\nCr√≠ticos: ",R)
    print("\nImunes: ",C)

    print(f"\nTaxa beta: {beta:.10f}")
    print(f"\nTaxa gamma:  {gamma:.10f}")
    print(f"\nTaxa beta imune: {betaR:.10f}\n")

    gerar_grafico(T, S, I, R, C, beta, gamma, betaR)

if __name__ == "__main__":
    runScript()

# 12 Experimento 04 04 Modelo SIR Projecao.ipynb

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint

# Fun√ß√£o do modelo SIR
def sir_model(y, t, beta, gamma):
    S, I, R = y
    dSdt = -beta * S * I
    dIdt = beta * S * I - gamma * I
    dRdt = gamma * I
    return [dSdt, dIdt, dRdt]

# Fun√ß√£o de simula√ß√£o e visualiza√ß√£o
def simular_SIR(S0, I0, R0, beta, gamma, dias=60):
    t = np.linspace(0, dias, 300)
    solution = odeint(sir_model, [S0, I0, R0], t, args=(beta, gamma))
    S, I, R = solution.T

    plt.figure(figsize=(10, 6))
    plt.plot(t, S, label='Suscet√≠veis', color='blue')
    plt.plot(t, I, label='Infectados', color='red')
    plt.plot(t, R, label='Recuperados', color='green')
    plt.xlabel('Tempo (dias)')
    plt.ylabel('N√∫mero de usu√°rios')
    plt.title(f'Simula√ß√£o Modelo SIR - Œ≤={beta}, Œ≥={gamma}')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

# Entrada de dados
if __name__ == "__main__":
    print("=== Simulador do Modelo SIR ===")
    S0 = int(input("Digite o n√∫mero inicial de suscet√≠veis (S0): "))
    I0 = int(input("Digite o n√∫mero inicial de infectados (I0): "))
    R0 = int(input("Digite o n√∫mero inicial de recuperados (R0): "))
    beta = float(input("Digite a taxa de infec√ß√£o (Œ≤): "))
    gamma = float(input("Digite a taxa de recupera√ß√£o (Œ≥): "))
    dias = int(input("Digite o n√∫mero de dias para simula√ß√£o: "))

    simular_SIR(S0, I0, R0, beta, gamma, dias)

## 14 Youtube Json - SIR leitura planilha excel, coleta de dados.
# 12_analise_dados_sir.py
# Ler de: estatistica_youtube_SIR.xlsx
# Grava em: analise_sir_data.json

# 1 - Collecting and analyzing data, generating rates and analysis charts.
# Fazer upload do arquivo de dados coletados da midia social e atualizar o caminho do arquivo na maquina linha "exelPath ="


import numpy as np
import pandas as pd
import plotly.graph_objects as go
import math
import json
import os

jsonArray = []


def getProximateTax(list):
    items = [1 if x == 0 else x for x in list]
    rates = [np.log(items[i+1]/items[i]) for i in range(len(items)-1)]
    rate_mid = np.mean(rates)
    return rate_mid


# MAIN METHOD
def runScript():
    global newTimesteps
    global newComments
    global newLikes
    global newTotalViews
    global newRecovered
    global newInfectious
    global newSusceptible
    global initialSusceptible
    global infectiousTableNumber
    global recoveredTableNumber
    global gammaRate
    global betaRate
    global keys
    global chooseFlow


    print("SIR - leitura planilha excel, coleta de dados, extrair taxas aproximadas.\n")

    initialSusceptible = int(input("Digite o n√∫mero inicial de suscet√≠veis: "))

    print("\nReceber dados.....\n")


    try:

        jsonFilePath = r'analise_sir_data.json'
        #criar o arquivo json se n√£o existir
        if not os.path.exists(jsonFilePath):
            with open(jsonFilePath, "w", encoding="utf-8") as f:
                json.dump([], f)


        exelPath = r'estatistica_youtube_SIR.xlsx'
        convert_excel_to_json(excel_path=exelPath, output_path=jsonFilePath)

        # Garante que o arquivo foi criado antes de tentar abrir
        if not os.path.exists(jsonFilePath):
            raise FileNotFoundError(f"O arquivo {jsonFilePath} n√£o foi criado. Verifique se o Excel existe e est√° correto.")

        jsonArray.clear()
        with open(jsonFilePath, "r", encoding="utf-8") as f:
            jsonArray.extend(json.load(f))

        print("""
                \nPara realizarmos a an√°lise, precisamos que voc√™ nos forne√ßa algumas informa√ß√µes
                sobre a tabela na planilha: estatistica_youtube_SIR.xlsx em termos de a que
                    cada coluna se refere.\n
                """)

        keys = getTableKeys(jsonArray)
        for indice, elemento in enumerate(keys):
            print(f"Digite {indice} -->  coluna: [ {elemento} ]")


        infectiousTableNumber = int(input("Infectados I : "))
        recoveredTableNumber = int(input("Recuperado R : "))

        newRecovered = list(map(lambda item: getCustomTableValue(item, keys[recoveredTableNumber]), jsonArray))
        newInfectious = list(map(lambda item: getCustomTableValue(item, keys[infectiousTableNumber]), jsonArray))

        newTimesteps = list(map(getTimeStep, jsonArray))
        newSusceptible = list(map(lambda item: getSusceptible(item, keys), jsonArray))
        newComments = list(map(getComments, jsonArray))
        newLikes = list(map(getLikes, jsonArray))
        newTotalViews = list(map(getTotalViews, jsonArray))

        generateStatisticCharts()

    except FileNotFoundError as e:
        print(f"Erro: {e}")
        print("Verifique se o arquivo Excel existe e est√° no caminho correto.")
    except ValueError as e:
        print(f"Erro: {e}")
        runScript()


def convert_excel_to_json(excel_path, sheet_name="P√°gina1", output_path="output.json"):
    try:
        df = pd.read_excel(excel_path, sheet_name=sheet_name)
        df = df.astype(str)
        json_data = df.to_json(orient="records", indent=4)
        jsonList = df.to_dict(orient="records")


        for row in jsonList:
            row_corrigido = {}
            for chave, valor in row.items():
                if valor.replace(".", "", 1).isdigit():  # Verifica se √© um n√∫mero (com ou sem ponto)
                    row_corrigido[chave] = str(int(float(valor)))  # Remove ponto decimal
                else:
                    row_corrigido[chave] = valor  # Mant√©m valores n√£o num√©ricos
            jsonArray.insert(0,row_corrigido)

        # Save JSON
        with open(output_path, "w", encoding="utf-8") as json_file:
            json_file.write(json_data)


    except Exception as e:
        print(f"Erro ao processar o arquivo: {e}")


def safe_convert_to_number(value):
    try:
        num = int(value)
        res = 0 if math.isnan(num) else num
        return res
    except (ValueError, TypeError):
        return int(0)

def getCustomTableValue(data , tableKey:str):
    value = data[tableKey]
    return safe_convert_to_number(value)

def getTimeStep(data):
    step = data["Timestep"]
    return int(step)

def getTimeDate(data):
    date = data["publishedAt"]
    return date

def getLikes(data):
    likes = data["likeCount"]
    return int(likes)

def getComments(data):
    comment = data["commentCount"]
    return int(comment)

def getTotalViews(data):
    views = data["viewCount"]
    return int(views)


def getTableKeys(data):
    return list(data[0].keys())

def getSusceptible(data , keys: list):
    totalInfec = data[keys[infectiousTableNumber]]
    totalRecover = data[keys[recoveredTableNumber]]
    n = initialSusceptible
    s = int(n) -  int(totalRecover) - int(totalInfec)

    return s

def generateStatisticCharts():
    global gammaRate
    global betaRate

    gammaRate = getProximateTax(newRecovered)
    betaRate = getProximateTax(newInfectious)

    layout = go.Layout(
    title={
        "text": '<b>SIR</b> - Taxas aproximadas: gamma: ' + str(round(gammaRate, 4)) +
                ', beta transmiss√£o: ' + str(round(betaRate, 4)),
        "font": {"size": 14}
    },
    xaxis={
        'title': 'Dias',
        'tickfont': {'size': 12}  # <-- tamanho da fonte do eixo X
    },
    yaxis={
        'title': 'Popula√ß√£o',
        'tickfont': {'size': 12}  # <-- tamanho da fonte do eixo Y
    },
)

    array_numpy_suscept = np.array(newSusceptible)
    susceptInt = array_numpy_suscept.astype('int32')

    trace1 = go.Scatter(
    x=newTimesteps,
    y=newSusceptible,
    mode='lines+markers+text',
    name= f"S - Suscet√≠vel, inicial: {initialSusceptible}",
    line=dict(color='blue', width=1),
    line_shape='spline',
    marker=dict(color="blue")
    )


    trace1_texts = go.Scatter(
            x=newTimesteps,
            y=newSusceptible,
            mode="text",
            text= susceptInt,
            textposition="top center",
            textfont=dict(
                size=12,
                color="blue",
            ),
            showlegend=False,
        )


    array_numpy_infect = np.array(newInfectious)
    infectInt = array_numpy_infect.astype('int32')

    trace2 = go.Scatter(
    x=newTimesteps,
    y=newInfectious,
    mode='lines+markers+text',
    name=f"S - Sugestionado - Infectado ('{keys[infectiousTableNumber]}')" ,
    line=dict(color='red', width=1),
    marker=dict(color="red"),
    line_shape='spline'
    )

    trace2_texts = go.Scatter(
            x=newTimesteps,
            y=newInfectious,
            mode="text",
            text= infectInt,
            textposition="bottom center",
            textfont=dict(
                size=12,
                color="red",
            ),
            showlegend=False,
        )


    array_numpy_recov = np.array(newRecovered)
    recovInt = array_numpy_recov.astype('int32')

    trace3 = go.Scatter(
        x=newTimesteps,
        y=newRecovered,
        mode='lines+markers',
        name=f"R - recuperado ('{keys[recoveredTableNumber]}')",
        line=dict(color='green', width=1),
        line_shape='spline',
        marker=dict(color="green")
    )

    trace3_texts = go.Scatter(
        x=newTimesteps,
        y=newRecovered,
        mode="text",
        text=recovInt,
        textposition="top center",

        textfont=dict(
            size=12,
            color="green",
        ),
        showlegend=False,
    )


    data=[trace1, trace1_texts, trace2, trace2_texts, trace3, trace3_texts]

    fig = go.Figure(data, layout = layout)

    fig.update_layout(
    legend_orientation="h",
    legend=dict(
        y=-0.30,
        x=0,
        orientation="v",
        font=dict(size=10)
    ),
    font=dict(size=18, color="gray"),
    xaxis=dict(tickangle=-45 )
)

    # fig.write_html("grafico_estatistica.html")
    # fig.write_image("grafico_estatistica.png", width=1200, height=800, scale=2)

    fig.show()

    print("\nGr√°fico construido com sucesso!\n\n")
    print("\nGR√ÅFICO SIR:\n ")
    print("\nlikes: ",newLikes)
    print("\ncomentarios: ",newComments)
    print("\nVisualiza√ß√µes Total: ",newTotalViews)

    print("\nSuscetiveis: ",newSusceptible)
    print("\nRecuperados:",newRecovered)
    print("\n Infectados: ",newInfectious)
    print("\nTaxa gamma: ",gammaRate)
    print("\nTaxa beta: ",betaRate)
    print("\n")


#Main method
runScript()

## 13 Experimento 04 Modelo SIR Retorna as taxas Beta;Gamma ***Planilha qualquer midia
## 13 Youtube - SIR leitura planilha excel, coleta de dados.
# calculo para extrair taxas gama e beta.
#13_analise_dados_ssc.py
# Ler de: content/estatistica_youtube_SSC.xlsx
# Grava em: content/analise_ssc_data.json

# 1 - Collecting and analyzing data, generating rates and analysis charts.
# Fazer upload do arquivo de dados coletados da midia social e atualizar o caminho do arquivo na maquina linha "exelPath ="


# 1 - Collecting and analyzing data, generating rates and analysis charts.

# 1 - Collecting and analyzing data, generating rates and analysis charts.

# 1 - Collecting and analyzing data, generating rates and analysis charts.

import numpy as np
import pandas as pd
import plotly.graph_objects as go
from scipy.integrate import odeint
import math


jsonArray = []


def estimar_gama_normalizado(N, I, R, delta_t):
    """
    Estima a taxa gama (recupera√ß√£o) usando propor√ß√µes de infectados e recuperados ao longo do tempo.
    F√≥rmula: gamma ‚âà m√©dia de [ (ŒîR / (I_m√©dio * Œît)) ]
    """
    # Convers√£o para propor√ß√µes
    I_prop = [i / N for i in I]
    R_prop = [r / N for r in R]

    gamas = []
    for t in range(len(I_prop) - 1):
        delta_r = R_prop[t + 1] - R_prop[t]
        i_medio = (I_prop[t + 1] + I_prop[t]) / 2
        if i_medio > 0:
            gamma_t = delta_r / (i_medio * delta_t)
            gamas.append(gamma_t)

    g = sum(gamas) / len(gamas) if gamas else 0.0
    return g / N


def estimar_beta_normalizado(N, S, I, R, delta_t):
    """
    Estima a taxa beta (transmiss√£o) usando propor√ß√µes de S, I, R ao longo do tempo.
    F√≥rmula: beta ‚âà m√©dia de [ (ŒîI + ŒîR) / (S_m√©dio * I_m√©dio * Œît) ]
    """

        # Convers√£o para propor√ß√µes
    I_prop = [i / N for i in I]
    R_prop = [r / N for r in R]
    S_prop = [s / N for s in S]

    betas = []
    for t in range(len(I_prop) - 1):
        delta_i = I_prop[t + 1] - I_prop[t]
        delta_r = R_prop[t + 1] - R_prop[t]
        s_medio = (S_prop[t + 1] + S_prop[t]) / 2
        i_medio = (I_prop[t + 1] + I_prop[t]) / 2
        if s_medio > 0 and i_medio > 0:
            beta_t = (delta_i + delta_r) / (s_medio * i_medio * delta_t)
            betas.append(beta_t)
    b = sum(betas) / len(betas) if betas else 0.0
    return b / N


# MAIN METHOD
def runScript():
    global newTimesteps
    global newRecovered
    global newInfectious
    global newSusceptible
    global initialSusceptible
    global gammaRate
    global betaRate


    print("SIR - leitura planilha excel, coleta de dados, extrair taxas aproximadas.\n")
    print("\nGerando gr√°fico.....\n")


    try:

        jsonFilePath = r'data.json'
        exelPath = r'estatistica_facebook_SSC.xlsx'
        convert_excel_to_json( excel_path= exelPath, output_path= jsonFilePath)

        newRecovered = list(map(getRecovered, jsonArray))
        newInfectious = list(map(getInfectius, jsonArray))


        newTimesteps = list(map(getTimeStep, jsonArray))
        newSusceptible = list(map(getSusceptible, jsonArray))

        initialSusceptible = newSusceptible[-1]

        generateStatisticCharts()

    except ValueError as e:
        print(f"Erro: {e}")
        runScript()


def convert_excel_to_json(excel_path, sheet_name="P√°gina1", output_path="output.json"):
    try:
        df = pd.read_excel(excel_path, sheet_name=sheet_name)
        df = df.astype(str)
        json_data = df.to_json(orient="records", indent=4)
        jsonList = df.to_dict(orient="records")


        for row in jsonList:
            row_corrigido = {}
            for chave, valor in row.items():
                if valor.replace(".", "", 1).isdigit():  # Verifica se √© um n√∫mero (com ou sem ponto)
                    row_corrigido[chave] = str(int(float(valor)))  # Remove ponto decimal
                else:
                    row_corrigido[chave] = valor  # Mant√©m valores n√£o num√©ricos
            jsonArray.insert(0,row_corrigido)

        # Save JSON
        with open(output_path, "w", encoding="utf-8") as json_file:
            json_file.write(json_data)


    except Exception as e:
        print(f"Erro ao processar o arquivo: {e}")


def safe_convert_to_number(value):
    try:
        num = int(value)
        res = 0 if math.isnan(num) else num
        return res
    except (ValueError, TypeError):
        return int(0)


def getTimeStep(data):
    step = data["Timestep"]
    return int(step)

def getTimeDate(data):
    date = data["publishedAt"]
    return date

def getInfectius(data):
    date = data["Sugestionado"]
    return int(date)

def getRecovered(data):
    date = data["Critico"]
    return int(date)

def getSusceptible(data):
    date = data["Suscetiveis"]
    return int(date)


def generateStatisticCharts():
    global gammaRate
    global betaRate
    global criticBetaRate
    global initialSusceptible

    gammaRate = estimar_gama_normalizado(initialSusceptible, newInfectious[::-1], newRecovered[::-1], 1)
    betaRate = estimar_beta_normalizado(initialSusceptible, newSusceptible[::-1], newInfectious[::-1], newRecovered[::-1], 1)

    layout = go.Layout(
    title={
        "text": '<b>SIR</b> - Taxas aproximadas: gamma: ' + str(round(gammaRate, 10)) +
                ', beta transmiss√£o: ' + str(round(betaRate, 10)) +
                ", Suscet√≠veis: " + str(initialSusceptible),
        "font": {"size": 16}
    },
    xaxis={
        'title': 'Dias',
        'tickfont': {'size': 14}  # <-- tamanho da fonte do eixo X
    },
    yaxis={
        'title': 'Popula√ß√£o',
        'tickfont': {'size': 14}  # <-- tamanho da fonte do eixo Y
    },
)

    array_numpy_suscept = np.array(newSusceptible)
    susceptInt = array_numpy_suscept.astype('int32')

    trace1 = go.Scatter(
    x=newTimesteps,
    y=newSusceptible,
    mode='lines+markers+text',
    name= f"S - Suscet√≠vel, inicial: {initialSusceptible}",
    line=dict(color='blue', width=1),
    line_shape='spline',
    marker=dict(color="blue")
    )


    trace1_texts = go.Scatter(
            x=newTimesteps,
            y=newSusceptible,
            mode="text",
            text= susceptInt,
            textposition="top center",
            textfont=dict(
                size=12,
                color="blue",
            ),
            showlegend=False,
        )


    array_numpy_infect = np.array(newInfectious)
    infectInt = array_numpy_infect.astype('int32')

    trace2 = go.Scatter(
    x=newTimesteps,
    y=newInfectious,
    mode='lines+markers+text',
    name="I - Infectado" ,
    line=dict(color='red', width=1),
    marker=dict(color="red"),
    line_shape='spline'
    )

    trace2_texts = go.Scatter(
            x=newTimesteps,
            y=newInfectious,
            mode="text",
            text= infectInt,
            textposition="bottom center",
            textfont=dict(
                size=12,
                color="red",
            ),
            showlegend=False,
        )


    array_numpy_recov = np.array(newRecovered)
    recovInt = array_numpy_recov.astype('int32')

    trace3 = go.Scatter(
        x=newTimesteps,
        y=newRecovered,
        mode='lines+markers',
        name= "R - Recuperado",
        line=dict(color='green', width=1),
        line_shape='spline',
        marker=dict(color="green")
    )

    trace3_texts = go.Scatter(
        x=newTimesteps,
        y=newRecovered,
        mode="text",
        text=recovInt,
        textposition="top center",

        textfont=dict(
            size=12,
            color="green",
        ),
        showlegend=False,
    )


    data=[trace1, trace1_texts, trace2, trace2_texts, trace3, trace3_texts]
    data2=[trace2, trace2_texts, trace3, trace3_texts]

    fig = go.Figure(data, layout = layout)
    fig2 = go.Figure(data2, layout = layout)

    fig.update_layout(
    legend_orientation="h",
    legend=dict(
        y=-0.30,
        x=0,
        orientation="v",
        font=dict(size=10)
    ),
    font=dict(size=18, color="gray"),
    xaxis=dict(tickangle=-45 )
)

    fig.show()

    print("\nGr√°fico construido com sucesso!\n\n")
    print("\nGR√ÅFICO SSC:\n ")

    print("\nSuscetiveis: ",newSusceptible)
    print("\nRecuperados:",newRecovered)
    print("\nInfectados: ",newInfectious)
    print("\nTaxa gamma: ", f"{gammaRate:.10f}")
    print("\nTaxa beta: ",f"{betaRate:.20f}")
    print("\n")

    fig2.show()



#Main method
runScript()

## 14 Youtube Json - SIR leitura planilha excel, coleta de dados.
# 12_analise_dados_sir.py
# Ler de: estatistica_youtube_SIR.xlsx
# Grava em: analise_sir_data.json

# 1 - Collecting and analyzing data, generating rates and analysis charts.
# Fazer upload do arquivo de dados coletados da midia social e atualizar o caminho do arquivo na maquina linha "exelPath ="


import numpy as np
import pandas as pd
import plotly.graph_objects as go
import math
import json
import os

jsonArray = []


def getProximateTax(list):
    items = [1 if x == 0 else x for x in list]
    rates = [np.log(items[i+1]/items[i]) for i in range(len(items)-1)]
    rate_mid = np.mean(rates)
    return rate_mid


# MAIN METHOD
def runScript():
    global newTimesteps
    global newComments
    global newLikes
    global newTotalViews
    global newRecovered
    global newInfectious
    global newSusceptible
    global initialSusceptible
    global infectiousTableNumber
    global recoveredTableNumber
    global gammaRate
    global betaRate
    global keys
    global chooseFlow


    print("SIR - leitura planilha excel, coleta de dados, extrair taxas aproximadas.\n")

    initialSusceptible = int(input("Digite o n√∫mero inicial de suscet√≠veis: "))

    print("\nReceber dados.....\n")


    try:

        jsonFilePath = r'analise_sir_data.json'
        #criar o arquivo json se n√£o existir
        if not os.path.exists(jsonFilePath):
            with open(jsonFilePath, "w", encoding="utf-8") as f:
                json.dump([], f)


        exelPath = r'estatistica_youtube_SIR.xlsx'
        convert_excel_to_json(excel_path=exelPath, output_path=jsonFilePath)

        # Garante que o arquivo foi criado antes de tentar abrir
        if not os.path.exists(jsonFilePath):
            raise FileNotFoundError(f"O arquivo {jsonFilePath} n√£o foi criado. Verifique se o Excel existe e est√° correto.")

        jsonArray.clear()
        with open(jsonFilePath, "r", encoding="utf-8") as f:
            jsonArray.extend(json.load(f))

        print("""
                \nPara realizarmos a an√°lise, precisamos que voc√™ nos forne√ßa algumas informa√ß√µes
                sobre a tabela na planilha: estatistica_youtube_SIR.xlsx em termos de a que
                    cada coluna se refere.\n
                """)

        keys = getTableKeys(jsonArray)
        for indice, elemento in enumerate(keys):
            print(f"Digite {indice} -->  coluna: [ {elemento} ]")


        infectiousTableNumber = int(input("Infectados I : "))
        recoveredTableNumber = int(input("Recuperado R : "))

        newRecovered = list(map(lambda item: getCustomTableValue(item, keys[recoveredTableNumber]), jsonArray))
        newInfectious = list(map(lambda item: getCustomTableValue(item, keys[infectiousTableNumber]), jsonArray))

        newTimesteps = list(map(getTimeStep, jsonArray))
        newSusceptible = list(map(lambda item: getSusceptible(item, keys), jsonArray))
        newComments = list(map(getComments, jsonArray))
        newLikes = list(map(getLikes, jsonArray))
        newTotalViews = list(map(getTotalViews, jsonArray))

        generateStatisticCharts()

    except FileNotFoundError as e:
        print(f"Erro: {e}")
        print("Verifique se o arquivo Excel existe e est√° no caminho correto.")
    except ValueError as e:
        print(f"Erro: {e}")
        runScript()


def convert_excel_to_json(excel_path, sheet_name="P√°gina1", output_path="output.json"):
    try:
        df = pd.read_excel(excel_path, sheet_name=sheet_name)
        df = df.astype(str)
        json_data = df.to_json(orient="records", indent=4)
        jsonList = df.to_dict(orient="records")


        for row in jsonList:
            row_corrigido = {}
            for chave, valor in row.items():
                if valor.replace(".", "", 1).isdigit():  # Verifica se √© um n√∫mero (com ou sem ponto)
                    row_corrigido[chave] = str(int(float(valor)))  # Remove ponto decimal
                else:
                    row_corrigido[chave] = valor  # Mant√©m valores n√£o num√©ricos
            jsonArray.insert(0,row_corrigido)

        # Save JSON
        with open(output_path, "w", encoding="utf-8") as json_file:
            json_file.write(json_data)


    except Exception as e:
        print(f"Erro ao processar o arquivo: {e}")


def safe_convert_to_number(value):
    try:
        num = int(value)
        res = 0 if math.isnan(num) else num
        return res
    except (ValueError, TypeError):
        return int(0)

def getCustomTableValue(data , tableKey:str):
    value = data[tableKey]
    return safe_convert_to_number(value)

def getTimeStep(data):
    step = data["Timestep"]
    return int(step)

def getTimeDate(data):
    date = data["publishedAt"]
    return date

def getLikes(data):
    likes = data["likeCount"]
    return int(likes)

def getComments(data):
    comment = data["commentCount"]
    return int(comment)

def getTotalViews(data):
    views = data["viewCount"]
    return int(views)


def getTableKeys(data):
    return list(data[0].keys())

def getSusceptible(data , keys: list):
    totalInfec = data[keys[infectiousTableNumber]]
    totalRecover = data[keys[recoveredTableNumber]]
    n = initialSusceptible
    s = int(n) -  int(totalRecover) - int(totalInfec)

    return s

def generateStatisticCharts():
    global gammaRate
    global betaRate

    gammaRate = getProximateTax(newRecovered)
    betaRate = getProximateTax(newInfectious)

    layout = go.Layout(
    title={
        "text": '<b>SIR</b> - Taxas aproximadas: gamma: ' + str(round(gammaRate, 4)) +
                ', beta transmiss√£o: ' + str(round(betaRate, 4)),
        "font": {"size": 14}
    },
    xaxis={
        'title': 'Dias',
        'tickfont': {'size': 12}  # <-- tamanho da fonte do eixo X
    },
    yaxis={
        'title': 'Popula√ß√£o',
        'tickfont': {'size': 12}  # <-- tamanho da fonte do eixo Y
    },
)

    array_numpy_suscept = np.array(newSusceptible)
    susceptInt = array_numpy_suscept.astype('int32')

    trace1 = go.Scatter(
    x=newTimesteps,
    y=newSusceptible,
    mode='lines+markers+text',
    name= f"S - Suscet√≠vel, inicial: {initialSusceptible}",
    line=dict(color='blue', width=1),
    line_shape='spline',
    marker=dict(color="blue")
    )


    trace1_texts = go.Scatter(
            x=newTimesteps,
            y=newSusceptible,
            mode="text",
            text= susceptInt,
            textposition="top center",
            textfont=dict(
                size=12,
                color="blue",
            ),
            showlegend=False,
        )


    array_numpy_infect = np.array(newInfectious)
    infectInt = array_numpy_infect.astype('int32')

    trace2 = go.Scatter(
    x=newTimesteps,
    y=newInfectious,
    mode='lines+markers+text',
    name=f"S - Sugestionado - Infectado ('{keys[infectiousTableNumber]}')" ,
    line=dict(color='red', width=1),
    marker=dict(color="red"),
    line_shape='spline'
    )

    trace2_texts = go.Scatter(
            x=newTimesteps,
            y=newInfectious,
            mode="text",
            text= infectInt,
            textposition="bottom center",
            textfont=dict(
                size=12,
                color="red",
            ),
            showlegend=False,
        )


    array_numpy_recov = np.array(newRecovered)
    recovInt = array_numpy_recov.astype('int32')

    trace3 = go.Scatter(
        x=newTimesteps,
        y=newRecovered,
        mode='lines+markers',
        name=f"R - recuperado ('{keys[recoveredTableNumber]}')",
        line=dict(color='green', width=1),
        line_shape='spline',
        marker=dict(color="green")
    )

    trace3_texts = go.Scatter(
        x=newTimesteps,
        y=newRecovered,
        mode="text",
        text=recovInt,
        textposition="top center",

        textfont=dict(
            size=12,
            color="green",
        ),
        showlegend=False,
    )


    data=[trace1, trace1_texts, trace2, trace2_texts, trace3, trace3_texts]

    fig = go.Figure(data, layout = layout)

    fig.update_layout(
    legend_orientation="h",
    legend=dict(
        y=-0.30,
        x=0,
        orientation="v",
        font=dict(size=10)
    ),
    font=dict(size=18, color="gray"),
    xaxis=dict(tickangle=-45 )
)

    # fig.write_html("grafico_estatistica.html")
    # fig.write_image("grafico_estatistica.png", width=1200, height=800, scale=2)

    fig.show()

    print("\nGr√°fico construido com sucesso!\n\n")
    print("\nGR√ÅFICO SIR:\n ")
    print("\nlikes: ",newLikes)
    print("\ncomentarios: ",newComments)
    print("\nVisualiza√ß√µes Total: ",newTotalViews)

    print("\nSuscetiveis: ",newSusceptible)
    print("\nRecuperados:",newRecovered)
    print("\n Infectados: ",newInfectious)
    print("\nTaxa gamma: ",gammaRate)
    print("\nTaxa beta: ",betaRate)
    print("\n")


#Main method
runScript()

# Modelo SIR Fixo
import numpy as np
from scipy.integrate import odeint
import plotly.graph_objects as go

# üßÆ Par√¢metros do modelo
N = 1000            # Popula√ß√£o total
I0 = 1              # Inicialmente sugestionado (infectado)
R0 = 0              # Inicialmente cr√≠tico (recuperado)
S0 = N - I0 - R0    # Suscet√≠veis no in√≠cio

beta = 0.3          # Taxa de infec√ß√£o (influ√™ncia)
gamma = 0.1         # Taxa de recupera√ß√£o
dias = 30           # N√∫mero de dias da simula√ß√£o

# üìê Equa√ß√µes diferenciais do modelo SIR tradicional
def sir(y, t, beta, gamma):
    S, I, R = y
    dSdt = -beta * S * I
    dIdt = beta * S * I - gamma * I
    dRdt = gamma * I
    return dSdt, dIdt, dRdt

# üß™ Simula√ß√£o do modelo
def simular_sir(S0, I0, R0, beta, gamma, dias):
    y0 = S0, I0, R0
    t = np.linspace(0, dias, dias)
    resultado = odeint(sir, y0, t, args=(beta, gamma))
    S, I, R = resultado.T
    return t, S, I, R

# üìä Gera√ß√£o do gr√°fico
def gerar_grafico():
    t, S, I, R = simular_sir(S0, I0, R0, beta, gamma, dias)

    fig = go.Figure()

    fig.add_trace(go.Scatter(x=t, y=S, mode='lines+markers', name='Suscet√≠veis', line=dict(color='blue')))
    fig.add_trace(go.Scatter(x=t, y=I, mode='lines+markers', name='Infectados', line=dict(color='red')))
    fig.add_trace(go.Scatter(x=t, y=R, mode='lines+markers', name='Recuerados', line=dict(color='green')))

    fig.update_layout(
        title=f"Modelo SIR Tradicional<br><sup>Œ≤={beta}, Œ≥={gamma}, N={N}</sup>",
        xaxis_title="Dias",
        yaxis_title="N√∫mero de Pessoas",
        font=dict(size=12),
        legend_orientation="h"
    )

    fig.show()

# ‚ñ∂Ô∏è Executar
gerar_grafico()

#Tentativa modelo SIR Adaptado Fixo
import numpy as np
from scipy.integrate import odeint
import plotly.graph_objects as go

# üßÆ Par√¢metros do modelo
N = 1000            # Popula√ß√£o total
I0 = 1              # Inicialmente sugestionado
R0 = 0              # Inicialmente cr√≠tico
S0 = N - I0 - R0    # Suscet√≠veis no in√≠cio

beta = 0.3          # Taxa de infec√ß√£o (influ√™ncia)
gamma = 0.1         # Taxa de recupera√ß√£o
beta_r = 0.05       # Taxa de resist√™ncia direta (S -> R) --- imune

dias = 30           # N√∫mero de dias da simula√ß√£o

# üìê Equa√ß√µes diferenciais do modelo SIR adaptado
def sir_resistente(y, t, beta, gamma, beta_r):
    S, I, R = y
    dSdt = -beta * S * I - beta_r * S
    dIdt = beta * S * I - gamma * I
    dRdt = gamma * I + beta_r * S
    return dSdt, dIdt, dRdt

# üß™ Simula√ß√£o do modelo
def simular_sir_resistente(S0, I0, R0, beta, gamma, beta_r, dias):
    y0 = S0, I0, R0
    t = np.linspace(0, dias, dias)
    resultado = odeint(sir_resistente, y0, t, args=(beta, gamma, beta_r))
    S, I, R = resultado.T
    return t, S, I, R

# üìä Gera√ß√£o do gr√°fico
def gerar_grafico():
    t, S, I, R = simular_sir_resistente(S0, I0, R0, beta, gamma, beta_r, dias)

    fig = go.Figure()

    fig.add_trace(go.Scatter(x=t, y=S, mode='lines+markers', name='Suscet√≠veis', line=dict(color='blue')))
    fig.add_trace(go.Scatter(x=t, y=I, mode='lines+markers', name='Sugestionados', line=dict(color='red')))
    fig.add_trace(go.Scatter(x=t, y=R, mode='lines+markers', name='Cr√≠ticos', line=dict(color='green')))

    fig.update_layout(
        title=f"Modelo SIR Adaptado com Resist√™ncia Direta<br><sup>Œ≤={beta}, Œ≥={gamma}, Œ¥={beta_r}, N={N}</sup>",
        xaxis_title="Dias",
        yaxis_title="N√∫mero de Pessoas",
        font=dict(size=12),
        legend_orientation="h"
    )

    fig.show()

# ‚ñ∂Ô∏è Executar
gerar_grafico()

# Exemplo SIR fixo
# import packages
import scipy.integrate
import numpy as np
import matplotlib.pyplot as plt

#ODES
def SIR_model(y, t, beta, gamma):
    S, I, R = y

    dS = -beta*S*I
    dI = beta*S*I - gamma*I
    dR = gamma*I

    return ([dS, dI, dR])

#time vector
t = np.linspace(0, 100,1000)

#Initial condition
S0 = 1000000
I0 = 37000
R0 = 60000
beta = 1.1
gamma = 0.27
Ro = beta/(gamma)
print('R0 =',Ro)

#solution
solution = scipy.integrate.odeint(SIR_model, [S0, I0, R0], t, args=(beta, gamma))


#plot result
plt.figure(figsize=[6,4])
plt.plot(t, solution[:, 0], label="S(t)")
plt.plot(t, solution[:, 1], label="I(t)")
plt.plot(t, solution[:, 2], label="R(t)")
plt.grid()
plt.legend()
plt.xlabel("Time")
plt.ylabel("Proportions")
plt.title("SIR model")
plt.show()

# Exemplo SIRD fixo
# import packages
# SIMULA
# 						        FACEBOOK			X								              YOUTUBE							          SIMULA 01	SIMULA 02	SIMULA 03
# S (Suscet√≠vel)		  2740909				5700000							          1680000							          9800		  15000		  1000000
# I (Sugestionado)		1661				  47+14+3 =64						        967+27=994						        100			  200			  37000
# R (Cr√≠tico/Resist)	20					  8817- (47 + 14) + 37 = 8793		188416 - (967) + 11= 187460		100			  2000		  60000

import scipy.integrate
import numpy as np
import matplotlib.pyplot as plt

#ODES
def SIRD_model(y, t, beta, gamma, delta):            #adding death separately from recovery
    S, I, R, D = y

    dS = -beta*S*I
    dI = beta*S*I - gamma*I - delta*I
    dR = gamma*I
    dD = delta*I

    return ([dS, dI, dR, dD])

#time vector
t = np.linspace(0, 100,1000)

#Initial condition
S0 = 1000000
I0 = 37000
R0 = 60000
D0 = 0
beta = 0.45
gamma = 0.1
delta = 0.15
Ro = beta/(delta+gamma)
print('R0 =',Ro)

#solution
solution = scipy.integrate.odeint(SIRD_model, [S0, I0, R0, D0], t, args=(beta, gamma, delta))


#plot result
plt.figure(figsize=[6,4])
plt.plot(t, solution[:, 0], label="S(t)")
plt.plot(t, solution[:, 1], label="I(t)")
plt.plot(t, solution[:, 2], label="R(t)")
plt.plot(t, solution[:, 3], label="D(t)")
plt.grid()
plt.legend()
plt.xlabel("Time")
plt.ylabel("Proportions")
plt.title("SIRD model")
plt.show()